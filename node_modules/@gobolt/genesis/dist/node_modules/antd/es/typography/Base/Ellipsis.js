import Q from "../../../../@babel/runtime/helpers/esm/toConsumableArray.js";
import * as e from "react";
import U from "../../../../rc-util/es/Children/toArray.js";
import w from "../../../../rc-util/es/hooks/useLayoutEffect.js";
import { isValidText as B } from "./util.js";
const b = e.forwardRef((m, u) => {
  let { style: c, children: s } = m;
  const t = e.useRef(null);
  return e.useImperativeHandle(u, () => ({ isExceed: () => {
    const n = t.current;
    return n.scrollHeight > n.clientHeight;
  }, getHeight: () => t.current.clientHeight })), e.createElement("span", { "aria-hidden": !0, ref: t, style: Object.assign({ position: "fixed", display: "block", left: 0, top: 0, pointerEvents: "none", backgroundColor: "rgba(255, 0, 0, 0.65)" }, c) }, s);
});
function L(m, u) {
  let c = 0;
  const s = [];
  for (let t = 0; t < m.length; t += 1) {
    if (c === u) return s;
    const n = m[t], p = c + (B(n) ? String(n).length : 1);
    if (p > u) {
      const O = u - c;
      return s.push(String(n).slice(0, O)), s;
    }
    s.push(n), c = p;
  }
  return m;
}
const x = 0, F = 4, v = { display: "-webkit-box", overflow: "hidden", WebkitBoxOrient: "vertical" };
function $(m) {
  const { enableMeasure: u, width: c, text: s, children: t, rows: n, expanded: p, miscDeps: O, onEllipsis: D } = m, g = e.useMemo(() => U(s), [s]), H = e.useMemo(() => ((r) => r.reduce((a, l) => a + (B(l) ? String(l).length : 1), 0))(g), [s]), k = e.useMemo(() => t(g, !1), [s]), [i, M] = e.useState(null), R = e.useRef(null), j = e.useRef(null), E = e.useRef(null), C = e.useRef(null), W = e.useRef(null), [I, N] = e.useState(!1), [d, S] = e.useState(x), [A, T] = e.useState(0), [V, q] = e.useState(null);
  w(() => {
    S(u && c && H ? 1 : x);
  }, [c, s, n, u, g]), w(() => {
    var r, a, l, f;
    if (d === 1) {
      S(2);
      const o = j.current && getComputedStyle(j.current).whiteSpace;
      q(o);
    } else if (d === 2) {
      const o = !!(!((r = E.current) === null || r === void 0) && r.isExceed());
      S(o ? 3 : F), M(o ? [0, H] : null), N(o);
      const G = ((a = E.current) === null || a === void 0 ? void 0 : a.getHeight()) || 0, J = n === 1 ? 0 : ((l = C.current) === null || l === void 0 ? void 0 : l.getHeight()) || 0, K = ((f = W.current) === null || f === void 0 ? void 0 : f.getHeight()) || 0, P = Math.max(G, J + K);
      T(P + 1), D(o);
    }
  }, [d]);
  const y = i ? Math.ceil((i[0] + i[1]) / 2) : 0;
  w(() => {
    var r;
    const [a, l] = i || [0, 0];
    if (a !== l) {
      const f = (((r = R.current) === null || r === void 0 ? void 0 : r.getHeight()) || 0) > A;
      let o = y;
      l - a == 1 && (o = f ? a : l), M(f ? [a, o] : [o, l]);
    }
  }, [i, y]);
  const z = e.useMemo(() => {
    if (!u) return t(g, !1);
    if (d !== 3 || !i || i[0] !== i[1]) {
      const r = t(g, !1);
      return [F, x].includes(d) ? r : e.createElement("span", { style: Object.assign(Object.assign({}, v), { WebkitLineClamp: n }) }, r);
    }
    return t(p ? g : L(g, i[0]), I);
  }, [p, d, i, g].concat(Q(O))), h = { width: c, margin: 0, padding: 0, whiteSpace: V === "nowrap" ? "normal" : "inherit" };
  return e.createElement(e.Fragment, null, z, d === 2 && e.createElement(e.Fragment, null, e.createElement(b, { style: Object.assign(Object.assign(Object.assign({}, h), v), { WebkitLineClamp: n }), ref: E }, k), e.createElement(b, { style: Object.assign(Object.assign(Object.assign({}, h), v), { WebkitLineClamp: n - 1 }), ref: C }, k), e.createElement(b, { style: Object.assign(Object.assign(Object.assign({}, h), v), { WebkitLineClamp: 1 }), ref: W }, t([], !0))), d === 3 && i && i[0] !== i[1] && e.createElement(b, { style: Object.assign(Object.assign({}, h), { top: 400 }), ref: R }, t(L(g, y), !0)), d === 1 && e.createElement("span", { style: { whiteSpace: "inherit" }, ref: j }));
}
export {
  $ as default
};
