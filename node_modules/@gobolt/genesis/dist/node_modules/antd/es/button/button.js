import a, { useMemo as ne, useContext as re, useState as se, useRef as ae, Children as Ie, useEffect as _ } from "react";
import I from "../../../../_virtual/index.js";
import Se from "../../../rc-util/es/omit.js";
import { useComposeRef as Te } from "../../../rc-util/es/ref.js";
import { devUseWarning as Pe } from "../_util/warning.js";
import we from "../_util/wave/index.js";
import { useComponentConfig as Be } from "../config-provider/context.js";
import De from "../config-provider/DisabledContext.js";
import Ve from "../config-provider/hooks/useSize.js";
import { useCompactItemContext as ze } from "../space/Compact.js";
import Re, { GroupSizeContext as Fe } from "./button-group.js";
import { isUnBorderedButtonVariant as y, isTwoCNChar as Ue, spaceChildren as Ae } from "./buttonHelpers.js";
import Ge from "./DefaultLoadingIcon.js";
import le from "./IconWrapper.js";
import Me from "./style/index.js";
import We from "./style/compact.js";
var qe = function(r, g) {
  var c = {};
  for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && g.indexOf(o) < 0 && (c[o] = r[o]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function") {
    var s = 0;
    for (o = Object.getOwnPropertySymbols(r); s < o.length; s++) g.indexOf(o[s]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[s]) && (c[o[s]] = r[o[s]]);
  }
  return c;
};
const He = { default: ["default", "outlined"], primary: ["primary", "solid"], dashed: ["default", "dashed"], link: ["link", "link"], text: ["default", "text"] }, S = a.forwardRef((r, g) => {
  var c, o;
  const { loading: s = !1, prefixCls: ie, color: b, variant: v, type: T, danger: N = !1, shape: C = "default", size: P, styles: w, disabled: B, className: ce, rootClassName: ue, children: u, icon: l, iconPosition: de = "start", ghost: D = !1, block: me = !1, htmlType: pe = "button", classNames: V, style: fe = {}, autoInsertSpace: z, autoFocus: ge } = r, R = qe(r, ["loading", "prefixCls", "color", "variant", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "iconPosition", "ghost", "block", "htmlType", "classNames", "style", "autoInsertSpace", "autoFocus"]), h = T || "default", [F, d] = ne(() => {
    if (b && v) return [b, v];
    const e = He[h] || [];
    return N ? ["danger", e[1]] : e;
  }, [T, b, v, N]), U = F === "danger" ? "dangerous" : F, { getPrefixCls: ye, direction: A, autoInsertSpace: be, className: ve, style: Ne, classNames: Ce, styles: he } = Be("button"), O = (c = z ?? be) === null || c === void 0 || c, t = ye("btn", ie), [G, Oe, $e] = Me(t), xe = re(De), m = B ?? xe, Ee = re(Fe), p = ne(() => function(e) {
    if (typeof e == "object" && e) {
      let n = e == null ? void 0 : e.delay;
      return n = Number.isNaN(n) || typeof n != "number" ? 0 : n, { loading: n <= 0, delay: n };
    }
    return { loading: !!e, delay: 0 };
  }(s), [s]), [i, M] = se(p.loading), [$, W] = se(!1), f = ae(null), q = Te(g, f), H = Ie.count(u) === 1 && !l && !y(d), x = ae(!0);
  a.useEffect(() => (x.current = !1, () => {
    x.current = !0;
  }), []), _(() => {
    let e = null;
    return p.delay > 0 ? e = setTimeout(() => {
      e = null, M(!0);
    }, p.delay) : M(p.loading), function() {
      e && (clearTimeout(e), e = null);
    };
  }, [p]), _(() => {
    if (!f.current || !O) return;
    const e = f.current.textContent || "";
    H && Ue(e) ? $ || W(!0) : $ && W(!1);
  }), _(() => {
    ge && f.current && f.current.focus();
  }, []);
  const J = a.useCallback((e) => {
    var n;
    i || m ? e.preventDefault() : (n = r.onClick) === null || n === void 0 || n.call(r, e);
  }, [r.onClick, i, m]);
  if (process.env.NODE_ENV !== "production") {
    const e = Pe("Button");
    process.env.NODE_ENV !== "production" && e(!(typeof l == "string" && l.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${l}\` at https://ant.design/components/icon`), process.env.NODE_ENV !== "production" && e(!(D && y(d)), "usage", "`link` or `text` button can't be a `ghost` button.");
  }
  const { compactSize: ke, compactItemClassnames: K } = ze(t, A), je = { large: "lg", small: "sm", middle: void 0 }, L = Ve((e) => {
    var n, j;
    return (j = (n = P ?? ke) !== null && n !== void 0 ? n : Ee) !== null && j !== void 0 ? j : e;
  }), Q = L && (o = je[L]) !== null && o !== void 0 ? o : "", _e = i ? "loading" : l, E = Se(R, ["navigate"]), X = I(t, Oe, $e, { [`${t}-${C}`]: C !== "default" && C, [`${t}-${h}`]: h, [`${t}-dangerous`]: N, [`${t}-color-${U}`]: U, [`${t}-variant-${d}`]: d, [`${t}-${Q}`]: Q, [`${t}-icon-only`]: !u && u !== 0 && !!_e, [`${t}-background-ghost`]: D && !y(d), [`${t}-loading`]: i, [`${t}-two-chinese-chars`]: $ && O && !i, [`${t}-block`]: me, [`${t}-rtl`]: A === "rtl", [`${t}-icon-end`]: de === "end" }, K, ce, ue, ve), Y = Object.assign(Object.assign({}, Ne), fe), Z = I(V == null ? void 0 : V.icon, Ce.icon), ee = Object.assign(Object.assign({}, (w == null ? void 0 : w.icon) || {}), he.icon || {}), te = l && !i ? a.createElement(le, { prefixCls: t, className: Z, style: ee }, l) : s && typeof s == "object" && s.icon ? a.createElement(le, { prefixCls: t, className: Z, style: ee }, s.icon) : a.createElement(Ge, { existIcon: !!l, prefixCls: t, loading: i, mount: x.current }), oe = u || u === 0 ? Ae(u, H && O) : null;
  if (E.href !== void 0) return G(a.createElement("a", Object.assign({}, E, { className: I(X, { [`${t}-disabled`]: m }), href: m ? void 0 : E.href, style: Y, onClick: J, ref: q, tabIndex: m ? -1 : 0 }), te, oe));
  let k = a.createElement("button", Object.assign({}, R, { type: pe, className: X, style: Y, onClick: J, disabled: m, ref: q }), te, oe, K && a.createElement(We, { prefixCls: t }));
  return y(d) || (k = a.createElement(we, { component: "Button", disabled: i }, k)), G(k);
});
S.Group = Re, S.__ANT_BUTTON = !0, process.env.NODE_ENV !== "production" && (S.displayName = "Button");
export {
  S as default
};
