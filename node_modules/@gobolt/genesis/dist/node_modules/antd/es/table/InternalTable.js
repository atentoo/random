import * as t from "react";
import h from "../../../../_virtual/index.js";
import { INTERNAL_HOOKS as Ze } from "../../../rc-table/es/constant.js";
import "../../../rc-table/es/Footer/index.js";
import "../../../rc-table/es/Table.js";
import "../../../rc-util/es/warning.js";
import "../../../rc-table/es/VirtualTable/index.js";
import { convertChildrenToColumns as qe } from "../../../rc-table/es/hooks/useColumns/index.js";
import Je from "../../../rc-util/es/omit.js";
import Qe from "../_util/hooks/useProxyImperativeHandle.js";
import Ye from "../_util/scrollTo.js";
import { devUseWarning as eo } from "../_util/warning.js";
import { ConfigContext as oo } from "../config-provider/context.js";
import to from "../config-provider/defaultRenderEmpty.js";
import no from "../config-provider/hooks/useCSSVarCls.js";
import ro from "../config-provider/hooks/useSize.js";
import io from "../grid/hooks/useBreakpoint.js";
import ao from "../locale/en_US.js";
import so from "../pagination/Pagination.js";
import lo from "../spin/index.js";
import "../../../@ant-design/cssinjs/es/extractStyle.js";
import "../../../@ant-design/cssinjs/es/hooks/useCacheToken.js";
import "../../../@ant-design/cssinjs/es/StyleContext.js";
import "../../../@ant-design/cssinjs/es/theme/createTheme.js";
import "../../../@ant-design/cssinjs/es/theme/ThemeCache.js";
import "../../../@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js";
import "../../../@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js";
import "../../../@ant-design/cssinjs/es/hooks/useHMR.js";
import "../../../@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js";
import "../../../rc-util/es/hooks/useLayoutEffect.js";
import "../../../rc-util/es/ref.js";
import "../../../@ant-design/cssinjs-utils/es/util/statistic.js";
import "../../../@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js";
import mo from "../theme/useToken.js";
import po from "./ExpandIcon.js";
import co from "./hooks/useContainerWidth.js";
import uo, { getFilterData as ge } from "./hooks/useFilter/index.js";
import go from "./hooks/useLazyKVMap.js";
import fo, { getPaginationParam as bo, DEFAULT_PAGE_SIZE as Co } from "./hooks/usePagination.js";
import vo from "./hooks/useSelection.js";
import xo, { getSortData as fe } from "./hooks/useSorter.js";
import ho from "./hooks/useTitleColumns.js";
import yo from "./RcTable/index.js";
import No from "./RcTable/VirtualTable.js";
import Oo from "./style/index.js";
const So = [], wo = (H, be) => {
  var R, z;
  const { prefixCls: Ce, className: ve, rootClassName: V, style: xe, size: he, bordered: ye, dropdownPrefixCls: Ne, dataSource: Oe, pagination: c, rowSelection: P, rowKey: C = "key", rowClassName: D, columns: W, children: U, childrenColumnName: Se, onChange: B, getPopupContainer: G, loading: O, expandIcon: we, expandable: y, expandedRowRender: Ie, expandIconColumnIndex: Ee, indentSize: X, scroll: Z, sortDirections: je, locale: S, showSorterTooltip: Te = { target: "full-header" }, virtual: q } = H, _ = eo("Table");
  process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && _(!(typeof C == "function" && C.length > 1), "usage", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.");
  const w = t.useMemo(() => W || qe(U), [W, U]), Re = t.useMemo(() => w.some((e) => e.responsive), [w]), M = io(Re), $ = t.useMemo(() => {
    const e = new Set(Object.keys(M).filter((o) => M[o]));
    return w.filter((o) => !o.responsive || o.responsive.some((n) => e.has(n)));
  }, [w, M]), ze = Je(H, ["className", "style", "columns"]), { locale: Pe = ao, direction: k, table: v, renderEmpty: J, getPrefixCls: Q, getPopupContainer: Y } = t.useContext(oo), x = ro(he), I = Object.assign(Object.assign({}, Pe.Table), S), f = Oe || So, r = Q("table", Ce), De = Q("dropdown", Ne), [, ee] = mo(), E = no(r), [_e, oe, te] = Oo(r, E), l = Object.assign(Object.assign({ childrenColumnName: Se, expandIconColumnIndex: Ee }, y), { expandIcon: (R = y == null ? void 0 : y.expandIcon) !== null && R !== void 0 ? R : (z = v == null ? void 0 : v.expandable) === null || z === void 0 ? void 0 : z.expandIcon }), { childrenColumnName: b = "children" } = l, ne = t.useMemo(() => f.some((e) => e == null ? void 0 : e[b]) ? "nest" : Ie || y != null && y.expandedRowRender ? "row" : null, [f]), A = { body: t.useRef(null) }, Me = co(r), re = t.useRef(null), ie = t.useRef(null);
  Qe(be, () => Object.assign(Object.assign({}, ie.current), { nativeElement: re.current }));
  const j = t.useMemo(() => typeof C == "function" ? C : (e) => e == null ? void 0 : e[C], [C]), [$e] = go(f, b, j), p = {}, K = function(e, o) {
    let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
    var a, m, u, g;
    const s = Object.assign(Object.assign({}, p), e);
    n && ((a = p.resetPagination) === null || a === void 0 || a.call(p), !((m = s.pagination) === null || m === void 0) && m.current && (s.pagination.current = 1), c && ((u = c.onChange) === null || u === void 0 || u.call(c, 1, (g = s.pagination) === null || g === void 0 ? void 0 : g.pageSize))), Z && Z.scrollToFirstRowOnChange !== !1 && A.body.current && Ye(0, { getContainer: () => A.body.current }), B == null || B(s.pagination, s.filters, s.sorter, { currentDataSource: ge(fe(f, s.sorterStates, b), s.filterStates, b), action: o });
  }, [ae, L, se, ke] = xo({ prefixCls: r, mergedColumns: $, onSorterChange: (e, o) => {
    K({ sorter: e, sorterStates: o }, "sort", !1);
  }, sortDirections: je || ["ascend", "descend"], tableLocale: I, showSorterTooltip: Te }), Ae = t.useMemo(() => fe(f, L, b), [f, L]);
  p.sorter = ke(), p.sorterStates = L;
  const [le, me, N] = uo({ prefixCls: r, locale: I, dropdownPrefixCls: De, mergedColumns: $, onFilterChange: (e, o) => {
    K({ filters: e, filterStates: o }, "filter", !0);
  }, getPopupContainer: G || Y, rootClassName: h(V, E) }), d = ge(Ae, me, b);
  p.filters = N, p.filterStates = me;
  const Ke = t.useMemo(() => {
    const e = {};
    return Object.keys(N).forEach((o) => {
      N[o] !== null && (e[o] = N[o]);
    }), Object.assign(Object.assign({}, se), { filters: e });
  }, [se, N]), [Le] = ho(Ke), [i, Fe] = fo(d.length, (e, o) => {
    K({ pagination: Object.assign(Object.assign({}, p.pagination), { current: e, pageSize: o }) }, "paginate");
  }, c);
  p.pagination = c === !1 ? {} : bo(i, c), p.resetPagination = Fe;
  const pe = t.useMemo(() => {
    if (c === !1 || !i.pageSize) return d;
    const { current: e = 1, total: o, pageSize: n = Co } = i;
    return process.env.NODE_ENV !== "production" && _(e > 0, "usage", "`current` should be positive number."), d.length < o ? d.length > n ? (process.env.NODE_ENV !== "production" && _(!1, "usage", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode."), d.slice((e - 1) * n, e * n)) : d : d.slice((e - 1) * n, e * n);
  }, [!!c, d, i == null ? void 0 : i.current, i == null ? void 0 : i.pageSize, i == null ? void 0 : i.total]), [ce, He] = vo({ prefixCls: r, data: d, pageData: pe, getRowKey: j, getRecordByKey: $e, expandType: ne, childrenColumnName: b, locale: I, getPopupContainer: G || Y }, P);
  l.__PARENT_RENDER_ICON__ = l.expandIcon, l.expandIcon = l.expandIcon || we || po(I), ne === "nest" && l.expandIconColumnIndex === void 0 ? l.expandIconColumnIndex = P ? 1 : 0 : l.expandIconColumnIndex > 0 && P && (l.expandIconColumnIndex -= 1), typeof l.indentSize != "number" && (l.indentSize = typeof X == "number" ? X : 15);
  const Ve = t.useCallback((e) => Le(ce(le(ae(e)))), [ae, le, ce]);
  let de, T, F;
  if (c !== !1 && (i != null && i.total)) {
    let e;
    e = i.size ? i.size : x === "small" || x === "middle" ? "small" : void 0;
    const o = (m) => t.createElement(so, Object.assign({}, i, { className: h(`${r}-pagination ${r}-pagination-${m}`, i.className), size: e })), n = k === "rtl" ? "left" : "right", { position: a } = i;
    if (a !== null && Array.isArray(a)) {
      const m = a.find((s) => s.includes("top")), u = a.find((s) => s.includes("bottom")), g = a.every((s) => `${s}` == "none");
      m || u || g || (T = o(n)), m && (de = o(m.toLowerCase().replace("top", ""))), u && (T = o(u.toLowerCase().replace("bottom", "")));
    } else T = o(n);
  }
  typeof O == "boolean" ? F = { spinning: O } : typeof O == "object" && (F = Object.assign({ spinning: !0 }, O));
  const We = h(te, E, `${r}-wrapper`, v == null ? void 0 : v.className, { [`${r}-wrapper-rtl`]: k === "rtl" }, ve, V, oe), Ue = Object.assign(Object.assign({}, v == null ? void 0 : v.style), xe), Be = (S == null ? void 0 : S.emptyText) !== void 0 ? S.emptyText : (J == null ? void 0 : J("Table")) || t.createElement(to, { componentName: "Table" }), Ge = q ? No : yo, ue = {}, Xe = t.useMemo(() => {
    const { fontSize: e, lineHeight: o, lineWidth: n, padding: a, paddingXS: m, paddingSM: u } = ee, g = Math.floor(e * o);
    switch (x) {
      case "middle":
        return 2 * u + g + n;
      case "small":
        return 2 * m + g + n;
      default:
        return 2 * a + g + n;
    }
  }, [ee, x]);
  return q && (ue.listItemHeight = Xe), _e(t.createElement("div", { ref: re, className: We, style: Ue }, t.createElement(lo, Object.assign({ spinning: !1 }, F), de, t.createElement(Ge, Object.assign({}, ue, ze, { ref: ie, columns: $, direction: k, expandable: l, prefixCls: r, className: h({ [`${r}-middle`]: x === "middle", [`${r}-small`]: x === "small", [`${r}-bordered`]: ye, [`${r}-empty`]: f.length === 0 }, te, E, oe), data: pe, rowKey: j, rowClassName: (e, o, n) => {
    let a;
    return a = h(typeof D == "function" ? D(e, o, n) : D), h({ [`${r}-row-selected`]: He.has(j(e, o)) }, a);
  }, emptyText: Be, internalHooks: Ze, internalRefs: A, transformColumns: Ve, getContainerWidth: Me })), T)));
}, bt = t.forwardRef(wo);
export {
  bt as default
};
