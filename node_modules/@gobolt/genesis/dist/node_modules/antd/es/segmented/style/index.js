import "../../../../@ant-design/cssinjs/es/extractStyle.js";
import "../../../../@ant-design/cssinjs/es/hooks/useCacheToken.js";
import "react";
import "../../../../@ant-design/cssinjs/es/StyleContext.js";
import { unit as i } from "../../../../@ant-design/cssinjs/es/util/index.js";
import "../../../../@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js";
import "../../../../@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js";
import "../../../../@ant-design/cssinjs/es/hooks/useHMR.js";
import "../../../../rc-util/es/warning.js";
import "../../../../@ant-design/cssinjs/es/theme/createTheme.js";
import "../../../../@ant-design/cssinjs/es/theme/ThemeCache.js";
import "../../../../@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js";
import { resetComponent as m, genFocusStyle as g, genFocusOutline as u, textEllipsis as b } from "../../style/index.js";
import "../../../../rc-util/es/hooks/useLayoutEffect.js";
import "../../../../rc-util/es/ref.js";
import { merge as p } from "../../../../@ant-design/cssinjs-utils/es/util/statistic.js";
import "../../../../@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js";
import { genStyleHooks as $ } from "../../theme/util/genStyleUtils.js";
function l(t, e) {
  return { [`${t}, ${t}:hover, ${t}:focus`]: { color: e.colorTextDisabled, cursor: "not-allowed" } };
}
function n(t) {
  return { backgroundColor: t.itemSelectedBg, boxShadow: t.boxShadowTertiary };
}
const h = Object.assign({ overflow: "hidden" }, b), S = (t) => {
  const { componentCls: e } = t, o = t.calc(t.controlHeight).sub(t.calc(t.trackPadding).mul(2)).equal(), r = t.calc(t.controlHeightLG).sub(t.calc(t.trackPadding).mul(2)).equal(), a = t.calc(t.controlHeightSM).sub(t.calc(t.trackPadding).mul(2)).equal();
  return { [e]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, m(t)), { display: "inline-block", padding: t.trackPadding, color: t.itemColor, background: t.trackBg, borderRadius: t.borderRadius, transition: `all ${t.motionDurationMid} ${t.motionEaseInOut}` }), g(t)), { [`${e}-group`]: { position: "relative", display: "flex", alignItems: "stretch", justifyItems: "flex-start", flexDirection: "row", width: "100%" }, [`&${e}-rtl`]: { direction: "rtl" }, [`&${e}-vertical`]: { [`${e}-group`]: { flexDirection: "column" }, [`${e}-thumb`]: { width: "100%", height: 0, padding: `0 ${i(t.paddingXXS)}` } }, [`&${e}-block`]: { display: "flex" }, [`&${e}-block ${e}-item`]: { flex: 1, minWidth: 0 }, [`${e}-item`]: { position: "relative", textAlign: "center", cursor: "pointer", transition: `color ${t.motionDurationMid} ${t.motionEaseInOut}`, borderRadius: t.borderRadiusSM, transform: "translateZ(0)", "&-selected": Object.assign(Object.assign({}, n(t)), { color: t.itemSelectedColor }), "&-focused": Object.assign({}, u(t)), "&::after": { content: '""', position: "absolute", zIndex: -1, width: "100%", height: "100%", top: 0, insetInlineStart: 0, borderRadius: "inherit", opacity: 0, transition: `opacity ${t.motionDurationMid}`, pointerEvents: "none" }, [`&:hover:not(${e}-item-selected):not(${e}-item-disabled)`]: { color: t.itemHoverColor, "&::after": { opacity: 1, backgroundColor: t.itemHoverBg } }, [`&:active:not(${e}-item-selected):not(${e}-item-disabled)`]: { color: t.itemHoverColor, "&::after": { opacity: 1, backgroundColor: t.itemActiveBg } }, "&-label": Object.assign({ minHeight: o, lineHeight: i(o), padding: `0 ${i(t.segmentedPaddingHorizontal)}` }, h), "&-icon + *": { marginInlineStart: t.calc(t.marginSM).div(2).equal() }, "&-input": { position: "absolute", insetBlockStart: 0, insetInlineStart: 0, width: 0, height: 0, opacity: 0, pointerEvents: "none" } }, [`${e}-thumb`]: Object.assign(Object.assign({}, n(t)), { position: "absolute", insetBlockStart: 0, insetInlineStart: 0, width: 0, height: "100%", padding: `${i(t.paddingXXS)} 0`, borderRadius: t.borderRadiusSM, transition: `transform ${t.motionDurationSlow} ${t.motionEaseInOut}, height ${t.motionDurationSlow} ${t.motionEaseInOut}`, [`& ~ ${e}-item:not(${e}-item-selected):not(${e}-item-disabled)::after`]: { backgroundColor: "transparent" } }), [`&${e}-lg`]: { borderRadius: t.borderRadiusLG, [`${e}-item-label`]: { minHeight: r, lineHeight: i(r), padding: `0 ${i(t.segmentedPaddingHorizontal)}`, fontSize: t.fontSizeLG }, [`${e}-item, ${e}-thumb`]: { borderRadius: t.borderRadius } }, [`&${e}-sm`]: { borderRadius: t.borderRadiusSM, [`${e}-item-label`]: { minHeight: a, lineHeight: i(a), padding: `0 ${i(t.segmentedPaddingHorizontalSM)}` }, [`${e}-item, ${e}-thumb`]: { borderRadius: t.borderRadiusXS } } }), l(`&-disabled ${e}-item`, t)), l(`${e}-item-disabled`, t)), { [`${e}-thumb-motion-appear-active`]: { transition: `transform ${t.motionDurationSlow} ${t.motionEaseInOut}, width ${t.motionDurationSlow} ${t.motionEaseInOut}`, willChange: "transform, width" }, [`&${e}-shape-round`]: { borderRadius: 9999, [`${e}-item, ${e}-thumb`]: { borderRadius: 9999 } } }) };
}, f = (t) => {
  const { colorTextLabel: e, colorText: o, colorFillSecondary: r, colorBgElevated: a, colorFill: d, lineWidthBold: s, colorBgLayout: c } = t;
  return { trackPadding: s, trackBg: c, itemColor: e, itemHoverColor: o, itemHoverBg: r, itemSelectedBg: a, itemActiveBg: d, itemSelectedColor: o };
}, L = $("Segmented", (t) => {
  const { lineWidth: e, calc: o } = t, r = p(t, { segmentedPaddingHorizontal: o(t.controlPaddingHorizontal).sub(e).equal(), segmentedPaddingHorizontalSM: o(t.controlPaddingHorizontalSM).sub(e).equal() });
  return [S(r)];
}, f);
export {
  L as default,
  f as prepareComponentToken
};
