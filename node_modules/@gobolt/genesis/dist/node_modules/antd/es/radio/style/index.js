import "../../../../@ant-design/cssinjs/es/extractStyle.js";
import "../../../../@ant-design/cssinjs/es/hooks/useCacheToken.js";
import "react";
import "../../../../@ant-design/cssinjs/es/StyleContext.js";
import { unit as S } from "../../../../@ant-design/cssinjs/es/util/index.js";
import "../../../../@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js";
import "../../../../@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js";
import "../../../../@ant-design/cssinjs/es/hooks/useHMR.js";
import "../../../../rc-util/es/warning.js";
import "../../../../@ant-design/cssinjs/es/theme/createTheme.js";
import "../../../../@ant-design/cssinjs/es/theme/ThemeCache.js";
import "../../../../@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js";
import { resetComponent as x, genFocusOutline as q } from "../../style/index.js";
import "../../../../rc-util/es/hooks/useLayoutEffect.js";
import "../../../../rc-util/es/ref.js";
import { merge as H } from "../../../../@ant-design/cssinjs-utils/es/util/statistic.js";
import "../../../../@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js";
import { genStyleHooks as P } from "../../theme/util/genStyleUtils.js";
const T = (t) => {
  const { componentCls: o, antCls: i } = t, e = `${o}-group`;
  return { [e]: Object.assign(Object.assign({}, x(t)), { display: "inline-block", fontSize: 0, [`&${e}-rtl`]: { direction: "rtl" }, [`&${e}-block`]: { display: "flex" }, [`${i}-badge ${i}-badge-count`]: { zIndex: 1 }, [`> ${i}-badge:not(:first-child) > ${i}-button-wrapper`]: { borderInlineStart: "none" } }) };
}, W = (t) => {
  const { componentCls: o, wrapperMarginInlineEnd: i, colorPrimary: e, radioSize: r, motionDurationSlow: a, motionDurationMid: l, motionEaseInOutCirc: c, colorBgContainer: s, colorBorder: C, lineWidth: k, colorBgContainerDisabled: u, colorTextDisabled: f, paddingXS: g, dotColorDisabled: m, lineType: y, radioColor: p, radioBgColor: $, calc: n } = t, h = `${o}-inner`, v = n(r).sub(n(4).mul(2)), b = n(1).mul(r).equal({ unit: !0 });
  return { [`${o}-wrapper`]: Object.assign(Object.assign({}, x(t)), { display: "inline-flex", alignItems: "baseline", marginInlineStart: 0, marginInlineEnd: i, cursor: "pointer", "&:last-child": { marginInlineEnd: 0 }, [`&${o}-wrapper-rtl`]: { direction: "rtl" }, "&-disabled": { cursor: "not-allowed", color: t.colorTextDisabled }, "&::after": { display: "inline-block", width: 0, overflow: "hidden", content: '"\\a0"' }, "&-block": { flex: 1, justifyContent: "center" }, [`${o}-checked::after`]: { position: "absolute", insetBlockStart: 0, insetInlineStart: 0, width: "100%", height: "100%", border: `${S(k)} ${y} ${e}`, borderRadius: "50%", visibility: "hidden", opacity: 0, content: '""' }, [o]: Object.assign(Object.assign({}, x(t)), { position: "relative", display: "inline-block", outline: "none", cursor: "pointer", alignSelf: "center", borderRadius: "50%" }), [`${o}-wrapper:hover &,
        &:hover ${h}`]: { borderColor: e }, [`${o}-input:focus-visible + ${h}`]: Object.assign({}, q(t)), [`${o}:hover::after, ${o}-wrapper:hover &::after`]: { visibility: "visible" }, [`${o}-inner`]: { "&::after": { boxSizing: "border-box", position: "absolute", insetBlockStart: "50%", insetInlineStart: "50%", display: "block", width: b, height: b, marginBlockStart: n(1).mul(r).div(-2).equal({ unit: !0 }), marginInlineStart: n(1).mul(r).div(-2).equal({ unit: !0 }), backgroundColor: p, borderBlockStart: 0, borderInlineStart: 0, borderRadius: b, transform: "scale(0)", opacity: 0, transition: `all ${a} ${c}`, content: '""' }, boxSizing: "border-box", position: "relative", insetBlockStart: 0, insetInlineStart: 0, display: "block", width: b, height: b, backgroundColor: s, borderColor: C, borderStyle: "solid", borderWidth: k, borderRadius: "50%", transition: `all ${l}` }, [`${o}-input`]: { position: "absolute", inset: 0, zIndex: 1, cursor: "pointer", opacity: 0 }, [`${o}-checked`]: { [h]: { borderColor: e, backgroundColor: $, "&::after": { transform: `scale(${t.calc(t.dotSize).div(r).equal()})`, opacity: 1, transition: `all ${a} ${c}` } } }, [`${o}-disabled`]: { cursor: "not-allowed", [h]: { backgroundColor: u, borderColor: C, cursor: "not-allowed", "&::after": { backgroundColor: m } }, [`${o}-input`]: { cursor: "not-allowed" }, [`${o}-disabled + span`]: { color: f, cursor: "not-allowed" }, [`&${o}-checked`]: { [h]: { "&::after": { transform: `scale(${n(v).div(r).equal()})` } } } }, [`span${o} + *`]: { paddingInlineStart: g, paddingInlineEnd: g } }) };
}, A = (t) => {
  const { buttonColor: o, controlHeight: i, componentCls: e, lineWidth: r, lineType: a, colorBorder: l, motionDurationSlow: c, motionDurationMid: s, buttonPaddingInline: C, fontSize: k, buttonBg: u, fontSizeLG: f, controlHeightLG: g, controlHeightSM: m, paddingXS: y, borderRadius: p, borderRadiusSM: $, borderRadiusLG: n, buttonCheckedBg: h, buttonSolidCheckedColor: v, colorTextDisabled: b, colorBgContainerDisabled: R, buttonCheckedBgDisabled: j, buttonCheckedColorDisabled: O, colorPrimary: B, colorPrimaryHover: w, colorPrimaryActive: I, buttonSolidCheckedBg: E, buttonSolidCheckedHoverBg: z, buttonSolidCheckedActiveBg: D, calc: d } = t;
  return { [`${e}-button-wrapper`]: { position: "relative", display: "inline-block", height: i, margin: 0, paddingInline: C, paddingBlock: 0, color: o, fontSize: k, lineHeight: S(d(i).sub(d(r).mul(2)).equal()), background: u, border: `${S(r)} ${a} ${l}`, borderBlockStartWidth: d(r).add(0.02).equal(), borderInlineStartWidth: 0, borderInlineEndWidth: r, cursor: "pointer", transition: [`color ${s}`, `background ${s}`, `box-shadow ${s}`].join(","), a: { color: o }, [`> ${e}-button`]: { position: "absolute", insetBlockStart: 0, insetInlineStart: 0, zIndex: -1, width: "100%", height: "100%" }, "&:not(:first-child)": { "&::before": { position: "absolute", insetBlockStart: d(r).mul(-1).equal(), insetInlineStart: d(r).mul(-1).equal(), display: "block", boxSizing: "content-box", width: 1, height: "100%", paddingBlock: r, paddingInline: 0, backgroundColor: l, transition: `background-color ${c}`, content: '""' } }, "&:first-child": { borderInlineStart: `${S(r)} ${a} ${l}`, borderStartStartRadius: p, borderEndStartRadius: p }, "&:last-child": { borderStartEndRadius: p, borderEndEndRadius: p }, "&:first-child:last-child": { borderRadius: p }, [`${e}-group-large &`]: { height: g, fontSize: f, lineHeight: S(d(g).sub(d(r).mul(2)).equal()), "&:first-child": { borderStartStartRadius: n, borderEndStartRadius: n }, "&:last-child": { borderStartEndRadius: n, borderEndEndRadius: n } }, [`${e}-group-small &`]: { height: m, paddingInline: d(y).sub(r).equal(), paddingBlock: 0, lineHeight: S(d(m).sub(d(r).mul(2)).equal()), "&:first-child": { borderStartStartRadius: $, borderEndStartRadius: $ }, "&:last-child": { borderStartEndRadius: $, borderEndEndRadius: $ } }, "&:hover": { position: "relative", color: B }, "&:has(:focus-visible)": Object.assign({}, q(t)), [`${e}-inner, input[type='checkbox'], input[type='radio']`]: { width: 0, height: 0, opacity: 0, pointerEvents: "none" }, [`&-checked:not(${e}-button-wrapper-disabled)`]: { zIndex: 1, color: B, background: h, borderColor: B, "&::before": { backgroundColor: B }, "&:first-child": { borderColor: B }, "&:hover": { color: w, borderColor: w, "&::before": { backgroundColor: w } }, "&:active": { color: I, borderColor: I, "&::before": { backgroundColor: I } } }, [`${e}-group-solid &-checked:not(${e}-button-wrapper-disabled)`]: { color: v, background: E, borderColor: E, "&:hover": { color: v, background: z, borderColor: z }, "&:active": { color: v, background: D, borderColor: D } }, "&-disabled": { color: b, backgroundColor: R, borderColor: l, cursor: "not-allowed", "&:first-child, &:hover": { color: b, backgroundColor: R, borderColor: l } }, [`&-disabled${e}-button-wrapper-checked`]: { color: O, backgroundColor: j, borderColor: l, boxShadow: "none" }, "&-block": { flex: 1, textAlign: "center" } } };
}, M = (t) => {
  const { wireframe: o, padding: i, marginXS: e, lineWidth: r, fontSizeLG: a, colorText: l, colorBgContainer: c, colorTextDisabled: s, controlItemBgActiveDisabled: C, colorTextLightSolid: k, colorPrimary: u, colorPrimaryHover: f, colorPrimaryActive: g, colorWhite: m } = t;
  return { radioSize: a, dotSize: o ? a - 8 : a - 2 * (4 + r), dotColorDisabled: s, buttonSolidCheckedColor: k, buttonSolidCheckedBg: u, buttonSolidCheckedHoverBg: f, buttonSolidCheckedActiveBg: g, buttonBg: c, buttonCheckedBg: c, buttonColor: l, buttonCheckedBgDisabled: C, buttonCheckedColorDisabled: s, buttonPaddingInline: i - r, wrapperMarginInlineEnd: e, radioColor: o ? u : m, radioBgColor: o ? c : u };
}, no = P("Radio", (t) => {
  const { controlOutline: o, controlOutlineWidth: i } = t, e = `0 0 0 ${S(i)} ${o}`, r = H(t, { radioFocusShadow: e, radioButtonFocusShadow: e });
  return [T(r), W(r), A(r)];
}, M, { unitless: { radioSize: !0, dotSize: !0 } });
export {
  no as default,
  M as prepareComponentToken
};
