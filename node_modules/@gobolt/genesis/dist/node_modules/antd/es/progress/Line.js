import * as c from "react";
import { presetPrimaryColors as v } from "../../../@ant-design/colors/es/presets.js";
import x from "../../../../_virtual/index.js";
import { devUseWarning as z } from "../_util/warning.js";
import { Percent as R, LineStrokeColorVar as b } from "./style/index.js";
import { getSize as _, validProgress as p, getSuccessPercent as L } from "./utils.js";
var G = function(r, t) {
  var n = {};
  for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && t.indexOf(e) < 0 && (n[e] = r[e]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function") {
    var o = 0;
    for (e = Object.getOwnPropertySymbols(r); o < e.length; o++) t.indexOf(e[o]) < 0 && Object.prototype.propertyIsEnumerable.call(r, e[o]) && (n[e[o]] = r[e[o]]);
  }
  return n;
};
const V = (r) => {
  let t = [];
  return Object.keys(r).forEach((n) => {
    const e = parseFloat(n.replace(/%/g, ""));
    Number.isNaN(e) || t.push({ key: e, value: r[n] });
  }), t = t.sort((n, e) => n.key - e.key), t.map((n) => {
    let { key: e, value: o } = n;
    return `${o} ${e}%`;
  }).join(", ");
}, q = (r, t) => {
  const { from: n = v.blue, to: e = v.blue, direction: o = t === "rtl" ? "to left" : "to right" } = r, i = G(r, ["from", "to", "direction"]);
  if (Object.keys(i).length !== 0) {
    const a = `linear-gradient(${o}, ${V(i)})`;
    return { background: a, [b]: a };
  }
  const s = `linear-gradient(${o}, ${n}, ${e})`;
  return { background: s, [b]: s };
}, B = (r) => {
  const { prefixCls: t, direction: n, percent: e, size: o, strokeWidth: i, strokeColor: s, strokeLinecap: a = "round", children: d, trailColor: $ = null, percentPosition: O, success: g } = r, { align: u, type: l } = O, N = s && typeof s != "string" ? q(s, n) : { [b]: s, background: s }, m = a === "square" || a === "butt" ? 0 : void 0, j = o ?? [-1, i || (o === "small" ? 6 : 8)], [f, y] = _(j, "line", { strokeWidth: i });
  process.env.NODE_ENV !== "production" && z("Progress").deprecated(!("strokeWidth" in r), "strokeWidth", "size");
  const E = { backgroundColor: $ || void 0, borderRadius: m }, P = Object.assign(Object.assign({ width: `${p(e)}%`, height: y, borderRadius: m }, N), { [R]: p(e) / 100 }), h = L(r), C = { width: `${p(h)}%`, height: y, borderRadius: m, backgroundColor: g == null ? void 0 : g.strokeColor }, w = { width: f < 0 ? "100%" : f }, k = c.createElement("div", { className: `${t}-inner`, style: E }, c.createElement("div", { className: x(`${t}-bg`, `${t}-bg-${l}`), style: P }, l === "inner" && d), h !== void 0 && c.createElement("div", { className: `${t}-success-bg`, style: C })), S = l === "outer" && u === "start", W = l === "outer" && u === "end";
  return l === "outer" && u === "center" ? c.createElement("div", { className: `${t}-layout-bottom` }, k, d) : c.createElement("div", { className: `${t}-outer`, style: w }, S && d, k, W && d);
};
export {
  B as default,
  q as handleGradient,
  V as sortGradient
};
