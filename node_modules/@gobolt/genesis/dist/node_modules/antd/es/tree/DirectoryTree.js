import D from "../../../@babel/runtime/helpers/esm/toConsumableArray.js";
import * as r from "react";
import V from "../../../@ant-design/icons/es/icons/FileOutlined.js";
import q from "../../../@ant-design/icons/es/icons/FolderOpenOutlined.js";
import z from "../../../@ant-design/icons/es/icons/FolderOutlined.js";
import B from "../../../../_virtual/index.js";
import { conductExpandParent as F } from "../../../rc-tree/es/util.js";
import { convertDataToEntities as G, convertTreeToData as H } from "../../../rc-tree/es/utils/treeUtil.js";
import "../config-provider/index.js";
import J from "./Tree.js";
import { convertDirectoryKeysToNodes as v, calcRangeKeys as M } from "./utils/dictUtil.js";
import { ConfigContext as Q } from "../config-provider/context.js";
var j = function(t, s) {
  var a = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && s.indexOf(n) < 0 && (a[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") {
    var l = 0;
    for (n = Object.getOwnPropertySymbols(t); l < n.length; l++) s.indexOf(n[l]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[l]) && (a[n[l]] = t[n[l]]);
  }
  return a;
};
function U(t) {
  const { isLeaf: s, expanded: a } = t;
  return s ? r.createElement(V, null) : a ? r.createElement(q, null) : r.createElement(z, null);
}
function w(t) {
  let { treeData: s, children: a } = t;
  return s || H(a);
}
const W = (t, s) => {
  var { defaultExpandAll: a, defaultExpandParent: n, defaultExpandedKeys: l } = t, e = j(t, ["defaultExpandAll", "defaultExpandParent", "defaultExpandedKeys"]);
  const x = r.useRef(null), K = r.useRef(null), [S, O] = r.useState(e.selectedKeys || e.defaultSelectedKeys || []), [N, b] = r.useState(() => (() => {
    const { keyEntities: c } = G(w(e));
    let d;
    return d = a ? Object.keys(c) : n ? F(e.expandedKeys || l || [], c) : e.expandedKeys || l || [], d;
  })());
  r.useEffect(() => {
    "selectedKeys" in e && O(e.selectedKeys);
  }, [e.selectedKeys]), r.useEffect(() => {
    "expandedKeys" in e && b(e.expandedKeys);
  }, [e.expandedKeys]);
  const { getPrefixCls: h, direction: A } = r.useContext(Q), { prefixCls: C, className: P, showIcon: T = !0, expandAction: k = "click" } = e, I = j(e, ["prefixCls", "className", "showIcon", "expandAction"]), E = h("tree", C), R = B(`${E}-directory`, { [`${E}-directory-rtl`]: A === "rtl" }, P);
  return r.createElement(J, Object.assign({ icon: U, ref: s, blockNode: !0 }, I, { showIcon: T, expandAction: k, prefixCls: E, className: R, expandedKeys: N, selectedKeys: S, onSelect: (c, d) => {
    var i;
    const { multiple: g, fieldNames: f } = e, { node: _, nativeEvent: p } = d, { key: u = "" } = _, y = w(e), m = Object.assign(Object.assign({}, d), { selected: !0 }), $ = (p == null ? void 0 : p.ctrlKey) || (p == null ? void 0 : p.metaKey), L = p == null ? void 0 : p.shiftKey;
    let o;
    g && $ ? (o = c, x.current = u, K.current = o, m.selectedNodes = v(y, o, f)) : g && L ? (o = Array.from(new Set([].concat(D(K.current || []), D(M({ treeData: y, expandedKeys: N, startKey: u, endKey: x.current, fieldNames: f }))))), m.selectedNodes = v(y, o, f)) : (o = [u], x.current = u, K.current = o, m.selectedNodes = v(y, o, f)), (i = e.onSelect) === null || i === void 0 || i.call(e, o, m), "selectedKeys" in e || O(o);
  }, onExpand: (c, d) => {
    var i;
    return "expandedKeys" in e || b(c), (i = e.onExpand) === null || i === void 0 ? void 0 : i.call(e, c, d);
  } }));
}, X = r.forwardRef(W);
process.env.NODE_ENV !== "production" && (X.displayName = "DirectoryTree");
export {
  X as default
};
