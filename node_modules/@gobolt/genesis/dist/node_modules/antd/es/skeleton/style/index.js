import "../../../../@ant-design/cssinjs/es/extractStyle.js";
import "../../../../@ant-design/cssinjs/es/hooks/useCacheToken.js";
import "react";
import "../../../../@ant-design/cssinjs/es/StyleContext.js";
import { unit as w } from "../../../../@ant-design/cssinjs/es/util/index.js";
import "../../../../@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js";
import "../../../../@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js";
import "../../../../@ant-design/cssinjs/es/hooks/useHMR.js";
import "../../../../rc-util/es/warning.js";
import B from "../../../../@ant-design/cssinjs/es/Keyframes.js";
import "../../../../@ant-design/cssinjs/es/theme/createTheme.js";
import "../../../../@ant-design/cssinjs/es/theme/ThemeCache.js";
import "../../../../@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js";
import "../../../../rc-util/es/hooks/useLayoutEffect.js";
import "../../../../rc-util/es/ref.js";
import { merge as f } from "../../../../@ant-design/cssinjs-utils/es/util/statistic.js";
import "../../../../@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js";
import { genStyleHooks as y } from "../../theme/util/genStyleUtils.js";
const E = new B("ant-skeleton-loading", { "0%": { backgroundPosition: "100% 50%" }, "100%": { backgroundPosition: "0 50%" } }), g = (e) => ({ height: e, lineHeight: w(e) }), s = (e) => Object.assign({ width: e }, g(e)), I = (e) => ({ background: e.skeletonLoadingBackground, backgroundSize: "400% 100%", animationName: E, animationDuration: e.skeletonLoadingMotionDuration, animationTimingFunction: "ease", animationIterationCount: "infinite" }), d = (e, n) => Object.assign({ width: n(e).mul(5).equal(), minWidth: n(e).mul(5).equal() }, g(e)), M = (e) => {
  const { skeletonAvatarCls: n, gradientFromColor: t, controlHeight: i, controlHeightLG: o, controlHeightSM: a } = e;
  return { [n]: Object.assign({ display: "inline-block", verticalAlign: "top", background: t }, s(i)), [`${n}${n}-circle`]: { borderRadius: "50%" }, [`${n}${n}-lg`]: Object.assign({}, s(o)), [`${n}${n}-sm`]: Object.assign({}, s(a)) };
}, A = (e) => {
  const { controlHeight: n, borderRadiusSM: t, skeletonInputCls: i, controlHeightLG: o, controlHeightSM: a, gradientFromColor: r, calc: l } = e;
  return { [i]: Object.assign({ display: "inline-block", verticalAlign: "top", background: r, borderRadius: t }, d(n, l)), [`${i}-lg`]: Object.assign({}, d(o, l)), [`${i}-sm`]: Object.assign({}, d(a, l)) };
}, h = (e) => Object.assign({ width: e }, g(e)), F = (e) => {
  const { skeletonImageCls: n, imageSizeBase: t, gradientFromColor: i, borderRadiusSM: o, calc: a } = e;
  return { [n]: Object.assign(Object.assign({ display: "inline-flex", alignItems: "center", justifyContent: "center", verticalAlign: "middle", background: i, borderRadius: o }, h(a(t).mul(2).equal())), { [`${n}-path`]: { fill: "#bfbfbf" }, [`${n}-svg`]: Object.assign(Object.assign({}, h(t)), { maxWidth: a(t).mul(4).equal(), maxHeight: a(t).mul(4).equal() }), [`${n}-svg${n}-svg-circle`]: { borderRadius: "50%" } }), [`${n}${n}-circle`]: { borderRadius: "50%" } };
}, m = (e, n, t) => {
  const { skeletonButtonCls: i } = e;
  return { [`${t}${i}-circle`]: { width: n, minWidth: n, borderRadius: "50%" }, [`${t}${i}-round`]: { borderRadius: n } };
}, u = (e, n) => Object.assign({ width: n(e).mul(2).equal(), minWidth: n(e).mul(2).equal() }, g(e)), L = (e) => {
  const { borderRadiusSM: n, skeletonButtonCls: t, controlHeight: i, controlHeightLG: o, controlHeightSM: a, gradientFromColor: r, calc: l } = e;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ [t]: Object.assign({ display: "inline-block", verticalAlign: "top", background: r, borderRadius: n, width: l(i).mul(2).equal(), minWidth: l(i).mul(2).equal() }, u(i, l)) }, m(e, i, t)), { [`${t}-lg`]: Object.assign({}, u(o, l)) }), m(e, o, `${t}-lg`)), { [`${t}-sm`]: Object.assign({}, u(a, l)) }), m(e, a, `${t}-sm`));
}, q = (e) => {
  const { componentCls: n, skeletonAvatarCls: t, skeletonTitleCls: i, skeletonParagraphCls: o, skeletonButtonCls: a, skeletonInputCls: r, skeletonImageCls: l, controlHeight: k, controlHeightLG: $, controlHeightSM: b, gradientFromColor: c, padding: S, marginSM: C, borderRadius: j, titleHeight: O, blockRadius: p, paragraphLiHeight: H, controlHeightXS: R, paragraphMarginTop: v } = e;
  return { [n]: { display: "table", width: "100%", [`${n}-header`]: { display: "table-cell", paddingInlineEnd: S, verticalAlign: "top", [t]: Object.assign({ display: "inline-block", verticalAlign: "top", background: c }, s(k)), [`${t}-circle`]: { borderRadius: "50%" }, [`${t}-lg`]: Object.assign({}, s($)), [`${t}-sm`]: Object.assign({}, s(b)) }, [`${n}-content`]: { display: "table-cell", width: "100%", verticalAlign: "top", [i]: { width: "100%", height: O, background: c, borderRadius: p, [`+ ${o}`]: { marginBlockStart: b } }, [o]: { padding: 0, "> li": { width: "100%", height: H, listStyle: "none", background: c, borderRadius: p, "+ li": { marginBlockStart: R } } }, [`${o}> li:last-child:not(:first-child):not(:nth-child(2))`]: { width: "61%" } }, [`&-round ${n}-content`]: { [`${i}, ${o} > li`]: { borderRadius: j } } }, [`${n}-with-avatar ${n}-content`]: { [i]: { marginBlockStart: C, [`+ ${o}`]: { marginBlockStart: v } } }, [`${n}${n}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({ display: "inline-block", width: "auto" }, L(e)), M(e)), A(e)), F(e)), [`${n}${n}-block`]: { width: "100%", [a]: { width: "100%" }, [r]: { width: "100%" } }, [`${n}${n}-active`]: { [`
        ${i},
        ${o} > li,
        ${t},
        ${a},
        ${r},
        ${l}
      `]: Object.assign({}, I(e)) } };
}, T = (e) => {
  const { colorFillContent: n, colorFill: t } = e;
  return { color: n, colorGradientEnd: t, gradientFromColor: n, gradientToColor: t, titleHeight: e.controlHeight / 2, blockRadius: e.borderRadiusSM, paragraphMarginTop: e.marginLG + e.marginXXS, paragraphLiHeight: e.controlHeight / 2 };
}, te = y("Skeleton", (e) => {
  const { componentCls: n, calc: t } = e, i = f(e, { skeletonAvatarCls: `${n}-avatar`, skeletonTitleCls: `${n}-title`, skeletonParagraphCls: `${n}-paragraph`, skeletonButtonCls: `${n}-button`, skeletonInputCls: `${n}-input`, skeletonImageCls: `${n}-image`, imageSizeBase: t(e.controlHeight).mul(1.5).equal(), borderRadius: 100, skeletonLoadingBackground: `linear-gradient(90deg, ${e.gradientFromColor} 25%, ${e.gradientToColor} 37%, ${e.gradientFromColor} 63%)`, skeletonLoadingMotionDuration: "1.4s" });
  return [q(i)];
}, T, { deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]] });
export {
  te as default,
  T as prepareComponentToken
};
