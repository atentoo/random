import "../../../@ant-design/cssinjs/es/extractStyle.js";
import "../../../@ant-design/cssinjs/es/hooks/useCacheToken.js";
import "react";
import "../../../@ant-design/cssinjs/es/StyleContext.js";
import { unit as s } from "../../../@ant-design/cssinjs/es/util/index.js";
import "../../../@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js";
import "../../../@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js";
import "../../../@ant-design/cssinjs/es/hooks/useHMR.js";
import "../../../rc-util/es/warning.js";
import "../../../@ant-design/cssinjs/es/theme/createTheme.js";
import "../../../@ant-design/cssinjs/es/theme/ThemeCache.js";
import "../../../@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js";
const z = { overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis" }, D = function(o) {
  let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
  return { boxSizing: "border-box", margin: 0, padding: 0, color: o.colorText, fontSize: o.fontSize, lineHeight: o.lineHeight, listStyle: "none", fontFamily: t ? "inherit" : o.fontFamily };
}, O = () => ({ display: "inline-flex", alignItems: "center", color: "inherit", fontStyle: "normal", lineHeight: 0, textAlign: "center", textTransform: "none", verticalAlign: "-0.125em", textRendering: "optimizeLegibility", "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale", "> *": { lineHeight: 1 }, svg: { display: "inline-block" } }), w = () => ({ "&::before": { display: "table", content: '""' }, "&::after": { display: "table", clear: "both", content: '""' } }), $ = (o) => ({ a: { color: o.colorLink, textDecoration: o.linkDecoration, backgroundColor: "transparent", outline: "none", cursor: "pointer", transition: `color ${o.motionDurationSlow}`, "-webkit-text-decoration-skip": "objects", "&:hover": { color: o.colorLinkHover }, "&:active": { color: o.colorLinkActive }, "&:active, &:hover": { textDecoration: o.linkHoverDecoration, outline: 0 }, "&:focus": { textDecoration: o.linkFocusDecoration, outline: 0 }, "&[disabled]": { color: o.colorTextDisabled, cursor: "not-allowed" } } }), j = (o, t, i, l) => {
  const n = `[class^="${t}"], [class*=" ${t}"]`, a = i ? `.${i}` : n, e = { boxSizing: "border-box", "&::before, &::after": { boxSizing: "border-box" } };
  let r = {};
  return l !== !1 && (r = { fontFamily: o.fontFamily, fontSize: o.fontSize }), { [a]: Object.assign(Object.assign(Object.assign({}, r), e), { [n]: e }) };
}, c = (o, t) => ({ outline: `${s(o.lineWidthFocus)} solid ${o.colorPrimaryBorder}`, outlineOffset: t ?? 1, transition: "outline-offset 0s, outline 0s" }), g = (o, t) => ({ "&:focus-visible": Object.assign({}, c(o, t)) }), F = (o) => ({ [`.${o}`]: Object.assign(Object.assign({}, { display: "inline-flex", alignItems: "center", color: "inherit", fontStyle: "normal", lineHeight: 0, textAlign: "center", textTransform: "none", verticalAlign: "-0.125em", textRendering: "optimizeLegibility", "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale", "> *": { lineHeight: 1 }, svg: { display: "inline-block" } }), { [`.${o} .${o}-icon`]: { display: "block" } }) }), H = (o) => Object.assign(Object.assign({ color: o.colorLink, textDecoration: o.linkDecoration, outline: "none", cursor: "pointer", transition: `all ${o.motionDurationSlow}`, border: 0, padding: 0, background: "none", userSelect: "none" }, g(o)), { "&:focus, &:hover": { color: o.colorLinkHover }, "&:active": { color: o.colorLinkActive } });
export {
  w as clearFix,
  j as genCommonStyle,
  c as genFocusOutline,
  g as genFocusStyle,
  F as genIconStyle,
  $ as genLinkStyle,
  H as operationUnit,
  D as resetComponent,
  O as resetIcon,
  z as textEllipsis
};
