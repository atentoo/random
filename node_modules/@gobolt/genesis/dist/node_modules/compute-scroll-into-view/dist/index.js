const $ = (t) => typeof t == "object" && t != null && t.nodeType === 1, tt = (t, o) => (!o || t !== "hidden") && t !== "visible" && t !== "clip", S = (t, o) => {
  if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
    const d = getComputedStyle(t, null);
    return tt(d.overflowY, o) || tt(d.overflowX, o) || ((c) => {
      const h = ((l) => {
        if (!l.ownerDocument || !l.ownerDocument.defaultView) return null;
        try {
          return l.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(c);
      return !!h && (h.clientHeight < c.scrollHeight || h.clientWidth < c.scrollWidth);
    })(t);
  }
  return !1;
}, X = (t, o, d, c, h, l, f, n) => l < t && f > o || l > t && f < o ? 0 : l <= t && n <= d || f >= o && n >= d ? l - t - c : f > o && n < d || l < t && n > d ? f - o + h : 0, nt = (t) => {
  const o = t.parentElement;
  return o ?? (t.getRootNode().host || null);
}, lt = (t, o) => {
  var d, c, h, l;
  if (typeof document > "u") return [];
  const { scrollMode: f, block: n, inline: u, boundary: Y, skipOverflowHiddenElements: et } = o, ot = typeof Y == "function" ? Y : (p) => p !== Y;
  if (!$(t)) throw new TypeError("Invalid target");
  const j = document.scrollingElement || document.documentElement, M = [];
  let r = t;
  for (; $(r) && ot(r); ) {
    if (r = nt(r), r === j) {
      M.push(r);
      break;
    }
    r != null && r === document.body && S(r) && !S(document.documentElement) || r != null && S(r, et) && M.push(r);
  }
  const m = (c = (d = window.visualViewport) == null ? void 0 : d.width) != null ? c : innerWidth, w = (l = (h = window.visualViewport) == null ? void 0 : h.height) != null ? l : innerHeight, { scrollX: W, scrollY: b } = window, { height: H, width: y, top: v, right: N, bottom: O, left: E } = t.getBoundingClientRect(), { top: K, right: P, bottom: Q, left: U } = ((p) => {
    const e = window.getComputedStyle(p);
    return { top: parseFloat(e.scrollMarginTop) || 0, right: parseFloat(e.scrollMarginRight) || 0, bottom: parseFloat(e.scrollMarginBottom) || 0, left: parseFloat(e.scrollMarginLeft) || 0 };
  })(t);
  let i = n === "start" || n === "nearest" ? v - K : n === "end" ? O + Q : v + H / 2 - K + Q, s = u === "center" ? E + y / 2 - U + P : u === "end" ? N + P : E - U;
  const q = [];
  for (let p = 0; p < M.length; p++) {
    const e = M[p], { height: x, width: C, top: F, right: z, bottom: A, left: I } = e.getBoundingClientRect();
    if (f === "if-needed" && v >= 0 && E >= 0 && O <= w && N <= m && (e === j && !S(e) || v >= F && O <= A && E >= I && N <= z)) return q;
    const R = getComputedStyle(e), T = parseInt(R.borderLeftWidth, 10), V = parseInt(R.borderTopWidth, 10), k = parseInt(R.borderRightWidth, 10), B = parseInt(R.borderBottomWidth, 10);
    let a = 0, g = 0;
    const D = "offsetWidth" in e ? e.offsetWidth - e.clientWidth - T - k : 0, L = "offsetHeight" in e ? e.offsetHeight - e.clientHeight - V - B : 0, G = "offsetWidth" in e ? e.offsetWidth === 0 ? 0 : C / e.offsetWidth : 0, J = "offsetHeight" in e ? e.offsetHeight === 0 ? 0 : x / e.offsetHeight : 0;
    if (j === e) a = n === "start" ? i : n === "end" ? i - w : n === "nearest" ? X(b, b + w, w, V, B, b + i, b + i + H, H) : i - w / 2, g = u === "start" ? s : u === "center" ? s - m / 2 : u === "end" ? s - m : X(W, W + m, m, T, k, W + s, W + s + y, y), a = Math.max(0, a + b), g = Math.max(0, g + W);
    else {
      a = n === "start" ? i - F - V : n === "end" ? i - A + B + L : n === "nearest" ? X(F, A, x, V, B + L, i, i + H, H) : i - (F + x / 2) + L / 2, g = u === "start" ? s - I - T : u === "center" ? s - (I + C / 2) + D / 2 : u === "end" ? s - z + k + D : X(I, z, C, T, k + D, s, s + y, y);
      const { scrollLeft: Z, scrollTop: _ } = e;
      a = J === 0 ? 0 : Math.max(0, Math.min(_ + a / J, e.scrollHeight - x / J + L)), g = G === 0 ? 0 : Math.max(0, Math.min(Z + g / G, e.scrollWidth - C / G + D)), i += _ - a, s += Z - g;
    }
    q.push({ el: e, top: a, left: g });
  }
  return q;
};
export {
  lt as compute
};
