import P from "../../../@babel/runtime/helpers/esm/extends.js";
import S from "../../../@babel/runtime/helpers/esm/objectSpread2.js";
import T from "../../../@babel/runtime/helpers/esm/defineProperty.js";
import k from "../../../../_virtual/index.js";
import * as l from "react";
import q from "../Cell/index.js";
import { responseImmutable as A } from "../context/TableContext.js";
import b from "../hooks/useRenderTimes.js";
import G from "../hooks/useRowInfo.js";
import H from "./ExpandedRow.js";
import { computedExpandedClassName as J } from "../utils/expandUtil.js";
function M(e, x, c, t, a) {
  var f, i, m = e.record, n = e.prefixCls, u = e.columnsKey, C = e.fixedInfoList, w = e.expandIconColumnIndex, o = e.nestExpandable, d = e.indentSize, N = e.expandIcon, y = e.expanded, v = e.hasNestChildren, p = e.onTriggerExpand, s = u[c], I = C[c];
  return c === (w || 0) && o && (f = l.createElement(l.Fragment, null, l.createElement("span", { style: { paddingLeft: "".concat(d * t, "px") }, className: "".concat(n, "-row-indent indent-level-").concat(t) }), N({ prefixCls: n, expanded: y, expandable: v, record: m, onExpand: p }))), x.onCell && (i = x.onCell(m, a)), { key: s, fixedInfo: I, appendCellNode: f, additionalCellProps: i || {} };
}
function D(e) {
  process.env.NODE_ENV !== "production" && b(e);
  var x = e.className, c = e.style, t = e.record, a = e.index, f = e.renderIndex, i = e.rowKey, m = e.indent, n = m === void 0 ? 0 : m, u = e.rowComponent, C = e.cellComponent, w = e.scopeCellComponent, o = G(t, i, a, n), d = o.prefixCls, N = o.flattenColumns, y = o.expandedRowClassName, v = o.expandedRowRender, p = o.rowProps, s = o.expanded, I = o.rowSupportExpand, g = l.useRef(!1);
  g.current || (g.current = s), process.env.NODE_ENV !== "production" && b(e);
  var R, h = J(y, t, a, n), _ = l.createElement(u, P({}, p, { "data-row-key": i, className: k(x, "".concat(d, "-row"), "".concat(d, "-row-level-").concat(n), p == null ? void 0 : p.className, T({}, h, n >= 1)), style: S(S({}, c), p == null ? void 0 : p.style) }), N.map(function(r, O) {
    var V = r.render, F = r.dataIndex, K = r.className, E = M(o, r, O, n, a), L = E.key, U = E.fixedInfo, j = E.appendCellNode, z = E.additionalCellProps;
    return l.createElement(q, P({ className: K, ellipsis: r.ellipsis, align: r.align, scope: r.rowScope, component: r.rowScope ? w : C, prefixCls: d, key: L, record: t, index: a, renderIndex: f, dataIndex: F, render: V, shouldCellUpdate: r.shouldCellUpdate }, U, { appendNode: j, additionalProps: z }));
  }));
  if (I && (g.current || s)) {
    var B = v(t, a, n + 1, s);
    R = l.createElement(H, { expanded: s, className: k("".concat(d, "-expanded-row"), "".concat(d, "-expanded-row-level-").concat(n + 1), h), prefixCls: d, component: u, cellComponent: C, colSpan: N.length, isEmpty: !1 }, B);
  }
  return l.createElement(l.Fragment, null, _, R);
}
process.env.NODE_ENV !== "production" && (D.displayName = "BodyRow");
const le = A(D);
export {
  le as default,
  M as getCellProps
};
