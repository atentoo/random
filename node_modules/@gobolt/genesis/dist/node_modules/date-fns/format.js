import { getDefaultOptions as w } from "./_lib/defaultOptions.js";
import { formatters as p } from "./_lib/format/formatters.js";
import { longFormatters as h } from "./_lib/format/longFormatters.js";
import { isProtectedWeekYearToken as d, isProtectedDayOfYearToken as v, warnOrThrowProtectedError as D } from "./_lib/protectedTokens.js";
import { isValid as T } from "./isValid.js";
import { toDate as S } from "./toDate.js";
import { enUS as O } from "./locale/en-US.js";
const P = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, z = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, E = /^'([^]*?)'?$/, W = /''/g, j = /[a-zA-Z]/;
function q(a, o, F) {
  var c, l, m, f;
  const t = w(), n = t.locale ?? O, u = t.firstWeekContainsDate ?? ((l = (c = t.locale) == null ? void 0 : c.options) == null ? void 0 : l.firstWeekContainsDate) ?? 1, k = t.weekStartsOn ?? ((f = (m = t.locale) == null ? void 0 : m.options) == null ? void 0 : f.weekStartsOn) ?? 0, s = S(a);
  if (!T(s)) throw new RangeError("Invalid time value");
  let i = o.match(z).map((r) => {
    const e = r[0];
    return e === "p" || e === "P" ? (0, h[e])(r, n.formatLong) : r;
  }).join("").match(P).map((r) => {
    if (r === "''") return { isToken: !1, value: "'" };
    const e = r[0];
    if (e === "'") return { isToken: !1, value: C(r) };
    if (p[e]) return { isToken: !0, value: r };
    if (e.match(j)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + e + "`");
    return { isToken: !1, value: r };
  });
  n.localize.preprocessor && (i = n.localize.preprocessor(s, i));
  const g = { firstWeekContainsDate: u, weekStartsOn: k, locale: n };
  return i.map((r) => {
    if (!r.isToken) return r.value;
    const e = r.value;
    return (d(e) || v(e)) && D(e, o, String(a)), (0, p[e[0]])(s, e, n.localize, g);
  }).join("");
}
function C(a) {
  const o = a.match(E);
  return o ? o[1].replace(W, "'") : a;
}
export {
  q as default,
  q as format,
  q as formatDate,
  p as formatters,
  h as longFormatters
};
