import ge from "../../@babel/runtime/helpers/esm/extends.js";
import ve from "../../@babel/runtime/helpers/esm/typeof.js";
import S from "../../@babel/runtime/helpers/esm/objectSpread2.js";
import Y from "../../@babel/runtime/helpers/esm/toConsumableArray.js";
import he from "../../@babel/runtime/helpers/esm/classCallCheck.js";
import Ke from "../../@babel/runtime/helpers/esm/createClass.js";
import p from "../../@babel/runtime/helpers/esm/assertThisInitialized.js";
import Ne from "../../@babel/runtime/helpers/esm/inherits.js";
import ke from "../../@babel/runtime/helpers/esm/createSuper.js";
import l from "../../@babel/runtime/helpers/esm/defineProperty.js";
import me from "../../../_virtual/index.js";
import M from "../../rc-util/es/KeyCode.js";
import Ee from "../../rc-util/es/pickAttrs.js";
import { warningOnce as F } from "../../rc-util/es/warning.js";
import * as W from "react";
import { TreeContext as De } from "./contextTypes.js";
import Ce from "./DropIndicator.js";
import xe, { MotionEntity as Pe, MOTION_KEY as _ } from "./NodeList.js";
import Se from "./TreeNode.js";
import { arrDel as w, getDragChildrenKeys as Te, calcDropPosition as V, arrAdd as b, posToArr as we, conductExpandParent as X, calcSelectedKeys as z, parseCheckedKeys as B } from "./util.js";
import { conductCheck as j } from "./utils/conductUtil.js";
import R from "./utils/keyUtil.js";
import { fillFieldNames as J, convertNodePropsToEventData as T, getTreeNodeProps as q, flattenTreeData as H, convertTreeToData as be, convertDataToEntities as Oe, warningWithoutKey as Le } from "./utils/treeUtil.js";
var Q = function(Z) {
  Ne(I, Z);
  var G = ke(I);
  function I() {
    var e;
    he(this, I);
    for (var h = arguments.length, m = new Array(h), E = 0; E < h; E++) m[E] = arguments[E];
    return e = G.call.apply(G, [this].concat(m)), l(p(e), "destroyed", !1), l(p(e), "delayedDragEnterLogic", void 0), l(p(e), "loadingRetryTimes", {}), l(p(e), "state", { keyEntities: {}, indent: null, selectedKeys: [], checkedKeys: [], halfCheckedKeys: [], loadedKeys: [], loadingKeys: [], expandedKeys: [], draggingNodeKey: null, dragChildrenKeys: [], dropTargetKey: null, dropPosition: null, dropContainerKey: null, dropLevelOffset: null, dropTargetPos: null, dropAllowed: !0, dragOverNodeKey: null, treeData: [], flattenNodes: [], focused: !1, activeKey: null, listChanging: !1, prevProps: null, fieldNames: J() }), l(p(e), "dragStartMousePosition", null), l(p(e), "dragNodeProps", null), l(p(e), "currentMouseOverDroppableNodeKey", null), l(p(e), "listRef", W.createRef()), l(p(e), "onNodeDragStart", function(t, n) {
      var o = e.state, a = o.expandedKeys, d = o.keyEntities, i = e.props.onDragStart, s = n.eventKey;
      e.dragNodeProps = n, e.dragStartMousePosition = { x: t.clientX, y: t.clientY };
      var y = w(a, s);
      e.setState({ draggingNodeKey: s, dragChildrenKeys: Te(s, d), indent: e.listRef.current.getIndentWidth() }), e.setExpandedKeys(y), window.addEventListener("dragend", e.onWindowDragEnd), i == null || i({ event: t, node: T(n) });
    }), l(p(e), "onNodeDragEnter", function(t, n) {
      var o = e.state, a = o.expandedKeys, d = o.keyEntities, i = o.dragChildrenKeys, s = o.flattenNodes, y = o.indent, v = e.props, r = v.onDragEnter, c = v.onExpand, K = v.allowDrop, u = v.direction, f = n.pos, N = n.eventKey;
      if (e.currentMouseOverDroppableNodeKey !== N && (e.currentMouseOverDroppableNodeKey = N), e.dragNodeProps) {
        var g = V(t, e.dragNodeProps, n, y, e.dragStartMousePosition, K, s, d, a, u), k = g.dropPosition, D = g.dropLevelOffset, C = g.dropTargetKey, x = g.dropContainerKey, O = g.dropTargetPos, P = g.dropAllowed, A = g.dragOverNodeKey;
        !i.includes(C) && P ? (e.delayedDragEnterLogic || (e.delayedDragEnterLogic = {}), Object.keys(e.delayedDragEnterLogic).forEach(function(L) {
          clearTimeout(e.delayedDragEnterLogic[L]);
        }), e.dragNodeProps.eventKey !== n.eventKey && (t.persist(), e.delayedDragEnterLogic[f] = window.setTimeout(function() {
          if (e.state.draggingNodeKey !== null) {
            var L = Y(a), U = R(d, n.eventKey);
            U && (U.children || []).length && (L = b(a, n.eventKey)), e.props.hasOwnProperty("expandedKeys") || e.setExpandedKeys(L), c == null || c(L, { node: T(n), expanded: !0, nativeEvent: t.nativeEvent });
          }
        }, 800)), e.dragNodeProps.eventKey !== C || D !== 0 ? (e.setState({ dragOverNodeKey: A, dropPosition: k, dropLevelOffset: D, dropTargetKey: C, dropContainerKey: x, dropTargetPos: O, dropAllowed: P }), r == null || r({ event: t, node: T(n), expandedKeys: a })) : e.resetDragState()) : e.resetDragState();
      } else e.resetDragState();
    }), l(p(e), "onNodeDragOver", function(t, n) {
      var o = e.state, a = o.dragChildrenKeys, d = o.flattenNodes, i = o.keyEntities, s = o.expandedKeys, y = o.indent, v = e.props, r = v.onDragOver, c = v.allowDrop, K = v.direction;
      if (e.dragNodeProps) {
        var u = V(t, e.dragNodeProps, n, y, e.dragStartMousePosition, c, d, i, s, K), f = u.dropPosition, N = u.dropLevelOffset, g = u.dropTargetKey, k = u.dropContainerKey, D = u.dropTargetPos, C = u.dropAllowed, x = u.dragOverNodeKey;
        !a.includes(g) && C && (e.dragNodeProps.eventKey === g && N === 0 ? e.state.dropPosition === null && e.state.dropLevelOffset === null && e.state.dropTargetKey === null && e.state.dropContainerKey === null && e.state.dropTargetPos === null && e.state.dropAllowed === !1 && e.state.dragOverNodeKey === null || e.resetDragState() : f === e.state.dropPosition && N === e.state.dropLevelOffset && g === e.state.dropTargetKey && k === e.state.dropContainerKey && D === e.state.dropTargetPos && C === e.state.dropAllowed && x === e.state.dragOverNodeKey || e.setState({ dropPosition: f, dropLevelOffset: N, dropTargetKey: g, dropContainerKey: k, dropTargetPos: D, dropAllowed: C, dragOverNodeKey: x }), r == null || r({ event: t, node: T(n) }));
      }
    }), l(p(e), "onNodeDragLeave", function(t, n) {
      e.currentMouseOverDroppableNodeKey !== n.eventKey || t.currentTarget.contains(t.relatedTarget) || (e.resetDragState(), e.currentMouseOverDroppableNodeKey = null);
      var o = e.props.onDragLeave;
      o == null || o({ event: t, node: T(n) });
    }), l(p(e), "onWindowDragEnd", function(t) {
      e.onNodeDragEnd(t, null, !0), window.removeEventListener("dragend", e.onWindowDragEnd);
    }), l(p(e), "onNodeDragEnd", function(t, n) {
      var o = e.props.onDragEnd;
      e.setState({ dragOverNodeKey: null }), e.cleanDragState(), o == null || o({ event: t, node: T(n) }), e.dragNodeProps = null, window.removeEventListener("dragend", e.onWindowDragEnd);
    }), l(p(e), "onNodeDrop", function(t, n) {
      var o, a = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], d = e.state, i = d.dragChildrenKeys, s = d.dropPosition, y = d.dropTargetKey, v = d.dropTargetPos;
      if (d.dropAllowed) {
        var r = e.props.onDrop;
        if (e.setState({ dragOverNodeKey: null }), e.cleanDragState(), y !== null) {
          var c = S(S({}, q(y, e.getTreeNodeRequiredProps())), {}, { active: ((o = e.getActiveItem()) === null || o === void 0 ? void 0 : o.key) === y, data: R(e.state.keyEntities, y).node }), K = i.includes(y);
          F(!K, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
          var u = we(v), f = { event: t, node: T(c), dragNode: e.dragNodeProps ? T(e.dragNodeProps) : null, dragNodesKeys: [e.dragNodeProps.eventKey].concat(i), dropToGap: s !== 0, dropPosition: s + Number(u[u.length - 1]) };
          a || r == null || r(f), e.dragNodeProps = null;
        }
      }
    }), l(p(e), "cleanDragState", function() {
      e.state.draggingNodeKey !== null && e.setState({ draggingNodeKey: null, dropPosition: null, dropContainerKey: null, dropTargetKey: null, dropLevelOffset: null, dropAllowed: !0, dragOverNodeKey: null }), e.dragStartMousePosition = null, e.currentMouseOverDroppableNodeKey = null;
    }), l(p(e), "triggerExpandActionExpand", function(t, n) {
      var o = e.state, a = o.expandedKeys, d = o.flattenNodes, i = n.expanded, s = n.key;
      if (!(n.isLeaf || t.shiftKey || t.metaKey || t.ctrlKey)) {
        var y = d.filter(function(r) {
          return r.key === s;
        })[0], v = T(S(S({}, q(s, e.getTreeNodeRequiredProps())), {}, { data: y.data }));
        e.setExpandedKeys(i ? w(a, s) : b(a, s)), e.onNodeExpand(t, v);
      }
    }), l(p(e), "onNodeClick", function(t, n) {
      var o = e.props, a = o.onClick;
      o.expandAction === "click" && e.triggerExpandActionExpand(t, n), a == null || a(t, n);
    }), l(p(e), "onNodeDoubleClick", function(t, n) {
      var o = e.props, a = o.onDoubleClick;
      o.expandAction === "doubleClick" && e.triggerExpandActionExpand(t, n), a == null || a(t, n);
    }), l(p(e), "onNodeSelect", function(t, n) {
      var o = e.state.selectedKeys, a = e.state, d = a.keyEntities, i = a.fieldNames, s = e.props, y = s.onSelect, v = s.multiple, r = n.selected, c = n[i.key], K = !r, u = (o = K ? v ? b(o, c) : [c] : w(o, c)).map(function(f) {
        var N = R(d, f);
        return N ? N.node : null;
      }).filter(Boolean);
      e.setUncontrolledState({ selectedKeys: o }), y == null || y(o, { event: "select", selected: K, node: n, selectedNodes: u, nativeEvent: t.nativeEvent });
    }), l(p(e), "onNodeCheck", function(t, n, o) {
      var a, d = e.state, i = d.keyEntities, s = d.checkedKeys, y = d.halfCheckedKeys, v = e.props, r = v.checkStrictly, c = v.onCheck, K = n.key, u = { event: "check", node: n, checked: o, nativeEvent: t.nativeEvent };
      if (r) {
        var f = o ? b(s, K) : w(s, K);
        a = { checked: f, halfChecked: w(y, K) }, u.checkedNodes = f.map(function(x) {
          return R(i, x);
        }).filter(Boolean).map(function(x) {
          return x.node;
        }), e.setUncontrolledState({ checkedKeys: f });
      } else {
        var N = j([].concat(Y(s), [K]), !0, i), g = N.checkedKeys, k = N.halfCheckedKeys;
        if (!o) {
          var D = new Set(g);
          D.delete(K);
          var C = j(Array.from(D), { halfCheckedKeys: k }, i);
          g = C.checkedKeys, k = C.halfCheckedKeys;
        }
        a = g, u.checkedNodes = [], u.checkedNodesPositions = [], u.halfCheckedKeys = k, g.forEach(function(x) {
          var O = R(i, x);
          if (O) {
            var P = O.node, A = O.pos;
            u.checkedNodes.push(P), u.checkedNodesPositions.push({ node: P, pos: A });
          }
        }), e.setUncontrolledState({ checkedKeys: g }, !1, { halfCheckedKeys: k });
      }
      c == null || c(a, u);
    }), l(p(e), "onNodeLoad", function(t) {
      var n, o = t.key, a = e.state.keyEntities, d = R(a, o);
      if (d == null || (n = d.children) === null || n === void 0 || !n.length) {
        var i = new Promise(function(s, y) {
          e.setState(function(v) {
            var r = v.loadedKeys, c = r === void 0 ? [] : r, K = v.loadingKeys, u = K === void 0 ? [] : K, f = e.props, N = f.loadData, g = f.onLoad;
            return !N || c.includes(o) || u.includes(o) ? null : (N(t).then(function() {
              var k = e.state.loadedKeys, D = b(k, o);
              g == null || g(D, { event: "load", node: t }), e.setUncontrolledState({ loadedKeys: D }), e.setState(function(C) {
                return { loadingKeys: w(C.loadingKeys, o) };
              }), s();
            }).catch(function(k) {
              if (e.setState(function(C) {
                return { loadingKeys: w(C.loadingKeys, o) };
              }), e.loadingRetryTimes[o] = (e.loadingRetryTimes[o] || 0) + 1, e.loadingRetryTimes[o] >= 10) {
                var D = e.state.loadedKeys;
                F(!1, "Retry for `loadData` many times but still failed. No more retry."), e.setUncontrolledState({ loadedKeys: b(D, o) }), s();
              }
              y(k);
            }), { loadingKeys: b(u, o) });
          });
        });
        return i.catch(function() {
        }), i;
      }
    }), l(p(e), "onNodeMouseEnter", function(t, n) {
      var o = e.props.onMouseEnter;
      o == null || o({ event: t, node: n });
    }), l(p(e), "onNodeMouseLeave", function(t, n) {
      var o = e.props.onMouseLeave;
      o == null || o({ event: t, node: n });
    }), l(p(e), "onNodeContextMenu", function(t, n) {
      var o = e.props.onRightClick;
      o && (t.preventDefault(), o({ event: t, node: n }));
    }), l(p(e), "onFocus", function() {
      var t = e.props.onFocus;
      e.setState({ focused: !0 });
      for (var n = arguments.length, o = new Array(n), a = 0; a < n; a++) o[a] = arguments[a];
      t == null || t.apply(void 0, o);
    }), l(p(e), "onBlur", function() {
      var t = e.props.onBlur;
      e.setState({ focused: !1 }), e.onActiveChange(null);
      for (var n = arguments.length, o = new Array(n), a = 0; a < n; a++) o[a] = arguments[a];
      t == null || t.apply(void 0, o);
    }), l(p(e), "getTreeNodeRequiredProps", function() {
      var t = e.state;
      return { expandedKeys: t.expandedKeys || [], selectedKeys: t.selectedKeys || [], loadedKeys: t.loadedKeys || [], loadingKeys: t.loadingKeys || [], checkedKeys: t.checkedKeys || [], halfCheckedKeys: t.halfCheckedKeys || [], dragOverNodeKey: t.dragOverNodeKey, dropPosition: t.dropPosition, keyEntities: t.keyEntities };
    }), l(p(e), "setExpandedKeys", function(t) {
      var n = e.state, o = n.treeData, a = n.fieldNames, d = H(o, t, a);
      e.setUncontrolledState({ expandedKeys: t, flattenNodes: d }, !0);
    }), l(p(e), "onNodeExpand", function(t, n) {
      var o = e.state.expandedKeys, a = e.state, d = a.listChanging, i = a.fieldNames, s = e.props, y = s.onExpand, v = s.loadData, r = n.expanded, c = n[i.key];
      if (!d) {
        var K = o.includes(c), u = !r;
        if (F(r && K || !r && !K, "Expand state not sync with index check"), o = u ? b(o, c) : w(o, c), e.setExpandedKeys(o), y == null || y(o, { node: n, expanded: u, nativeEvent: t.nativeEvent }), u && v) {
          var f = e.onNodeLoad(n);
          f && f.then(function() {
            var N = H(e.state.treeData, o, i);
            e.setUncontrolledState({ flattenNodes: N });
          }).catch(function() {
            var N = e.state.expandedKeys, g = w(N, c);
            e.setExpandedKeys(g);
          });
        }
      }
    }), l(p(e), "onListChangeStart", function() {
      e.setUncontrolledState({ listChanging: !0 });
    }), l(p(e), "onListChangeEnd", function() {
      setTimeout(function() {
        e.setUncontrolledState({ listChanging: !1 });
      });
    }), l(p(e), "onActiveChange", function(t) {
      var n = e.state.activeKey, o = e.props, a = o.onActiveChange, d = o.itemScrollOffset, i = d === void 0 ? 0 : d;
      n !== t && (e.setState({ activeKey: t }), t !== null && e.scrollTo({ key: t, offset: i }), a == null || a(t));
    }), l(p(e), "getActiveItem", function() {
      var t = e.state, n = t.activeKey, o = t.flattenNodes;
      return n === null ? null : o.find(function(a) {
        return a.key === n;
      }) || null;
    }), l(p(e), "offsetActiveKey", function(t) {
      var n = e.state, o = n.flattenNodes, a = n.activeKey, d = o.findIndex(function(y) {
        return y.key === a;
      });
      d === -1 && t < 0 && (d = o.length);
      var i = o[d = (d + t + o.length) % o.length];
      if (i) {
        var s = i.key;
        e.onActiveChange(s);
      } else e.onActiveChange(null);
    }), l(p(e), "onKeyDown", function(t) {
      var n = e.state, o = n.activeKey, a = n.expandedKeys, d = n.checkedKeys, i = n.fieldNames, s = e.props, y = s.onKeyDown, v = s.checkable, r = s.selectable;
      switch (t.which) {
        case M.UP:
          e.offsetActiveKey(-1), t.preventDefault();
          break;
        case M.DOWN:
          e.offsetActiveKey(1), t.preventDefault();
      }
      var c = e.getActiveItem();
      if (c && c.data) {
        var K = e.getTreeNodeRequiredProps(), u = c.data.isLeaf === !1 || !!(c.data[i.children] || []).length, f = T(S(S({}, q(o, K)), {}, { data: c.data, active: !0 }));
        switch (t.which) {
          case M.LEFT:
            u && a.includes(o) ? e.onNodeExpand({}, f) : c.parent && e.onActiveChange(c.parent.key), t.preventDefault();
            break;
          case M.RIGHT:
            u && !a.includes(o) ? e.onNodeExpand({}, f) : c.children && c.children.length && e.onActiveChange(c.children[0].key), t.preventDefault();
            break;
          case M.ENTER:
          case M.SPACE:
            !v || f.disabled || f.checkable === !1 || f.disableCheckbox ? v || !r || f.disabled || f.selectable === !1 || e.onNodeSelect({}, f) : e.onNodeCheck({}, f, !d.includes(o));
        }
      }
      y == null || y(t);
    }), l(p(e), "setUncontrolledState", function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!e.destroyed) {
        var a = !1, d = !0, i = {};
        Object.keys(t).forEach(function(s) {
          e.props.hasOwnProperty(s) ? d = !1 : (a = !0, i[s] = t[s]);
        }), !a || n && !d || e.setState(S(S({}, i), o));
      }
    }), l(p(e), "scrollTo", function(t) {
      e.listRef.current.scrollTo(t);
    }), e;
  }
  return Ke(I, [{ key: "componentDidMount", value: function() {
    this.destroyed = !1, this.onUpdated();
  } }, { key: "componentDidUpdate", value: function() {
    this.onUpdated();
  } }, { key: "onUpdated", value: function() {
    var e = this.props, h = e.activeKey, m = e.itemScrollOffset, E = m === void 0 ? 0 : m;
    h !== void 0 && h !== this.state.activeKey && (this.setState({ activeKey: h }), h !== null && this.scrollTo({ key: h, offset: E }));
  } }, { key: "componentWillUnmount", value: function() {
    window.removeEventListener("dragend", this.onWindowDragEnd), this.destroyed = !0;
  } }, { key: "resetDragState", value: function() {
    this.setState({ dragOverNodeKey: null, dropPosition: null, dropLevelOffset: null, dropTargetKey: null, dropContainerKey: null, dropTargetPos: null, dropAllowed: !1 });
  } }, { key: "render", value: function() {
    var e, h = this.state, m = h.focused, E = h.flattenNodes, t = h.keyEntities, n = h.draggingNodeKey, o = h.activeKey, a = h.dropLevelOffset, d = h.dropContainerKey, i = h.dropTargetKey, s = h.dropPosition, y = h.dragOverNodeKey, v = h.indent, r = this.props, c = r.prefixCls, K = r.className, u = r.style, f = r.showLine, N = r.focusable, g = r.tabIndex, k = g === void 0 ? 0 : g, D = r.selectable, C = r.showIcon, x = r.icon, O = r.switcherIcon, P = r.draggable, A = r.checkable, L = r.checkStrictly, U = r.disabled, $ = r.motion, ee = r.loadData, te = r.filterTreeNode, oe = r.height, ne = r.itemHeight, ae = r.scrollWidth, re = r.virtual, de = r.titleRender, se = r.dropIndicatorRender, le = r.onContextMenu, ie = r.onScroll, ce = r.direction, pe = r.rootClassName, ue = r.rootStyle, ye = Ee(this.props, { aria: !0, data: !0 });
    P && (e = ve(P) === "object" ? P : typeof P == "function" ? { nodeDraggable: P } : {});
    var fe = { prefixCls: c, selectable: D, showIcon: C, icon: x, switcherIcon: O, draggable: e, draggingNodeKey: n, checkable: A, checkStrictly: L, disabled: U, keyEntities: t, dropLevelOffset: a, dropContainerKey: d, dropTargetKey: i, dropPosition: s, dragOverNodeKey: y, indent: v, direction: ce, dropIndicatorRender: se, loadData: ee, filterTreeNode: te, titleRender: de, onNodeClick: this.onNodeClick, onNodeDoubleClick: this.onNodeDoubleClick, onNodeExpand: this.onNodeExpand, onNodeSelect: this.onNodeSelect, onNodeCheck: this.onNodeCheck, onNodeLoad: this.onNodeLoad, onNodeMouseEnter: this.onNodeMouseEnter, onNodeMouseLeave: this.onNodeMouseLeave, onNodeContextMenu: this.onNodeContextMenu, onNodeDragStart: this.onNodeDragStart, onNodeDragEnter: this.onNodeDragEnter, onNodeDragOver: this.onNodeDragOver, onNodeDragLeave: this.onNodeDragLeave, onNodeDragEnd: this.onNodeDragEnd, onNodeDrop: this.onNodeDrop };
    return W.createElement(De.Provider, { value: fe }, W.createElement("div", { className: me(c, K, pe, l(l(l({}, "".concat(c, "-show-line"), f), "".concat(c, "-focused"), m), "".concat(c, "-active-focused"), o !== null)), style: ue }, W.createElement(xe, ge({ ref: this.listRef, prefixCls: c, style: u, data: E, disabled: U, selectable: D, checkable: !!A, motion: $, dragging: n !== null, height: oe, itemHeight: ne, virtual: re, focusable: N, focused: m, tabIndex: k, activeItem: this.getActiveItem(), onFocus: this.onFocus, onBlur: this.onBlur, onKeyDown: this.onKeyDown, onActiveChange: this.onActiveChange, onListChangeStart: this.onListChangeStart, onListChangeEnd: this.onListChangeEnd, onContextMenu: le, onScroll: ie, scrollWidth: ae }, this.getTreeNodeRequiredProps(), ye))));
  } }], [{ key: "getDerivedStateFromProps", value: function(e, h) {
    var m, E = h.prevProps, t = { prevProps: e };
    function n(g) {
      return !E && e.hasOwnProperty(g) || E && E[g] !== e[g];
    }
    var o = h.fieldNames;
    if (n("fieldNames") && (o = J(e.fieldNames), t.fieldNames = o), n("treeData") ? m = e.treeData : n("children") && (F(!1, "`children` of Tree is deprecated. Please use `treeData` instead."), m = be(e.children)), m) {
      t.treeData = m;
      var a = Oe(m, { fieldNames: o });
      t.keyEntities = S(l({}, _, Pe), a.keyEntities), process.env.NODE_ENV !== "production" && Le(m, o);
    }
    var d, i = t.keyEntities || h.keyEntities;
    if (n("expandedKeys") || E && n("autoExpandParent")) t.expandedKeys = e.autoExpandParent || !E && e.defaultExpandParent ? X(e.expandedKeys, i) : e.expandedKeys;
    else if (!E && e.defaultExpandAll) {
      var s = S({}, i);
      delete s[_];
      var y = [];
      Object.keys(s).forEach(function(g) {
        var k = s[g];
        k.children && k.children.length && y.push(k.key);
      }), t.expandedKeys = y;
    } else !E && e.defaultExpandedKeys && (t.expandedKeys = e.autoExpandParent || e.defaultExpandParent ? X(e.defaultExpandedKeys, i) : e.defaultExpandedKeys);
    if (t.expandedKeys || delete t.expandedKeys, m || t.expandedKeys) {
      var v = H(m || h.treeData, t.expandedKeys || h.expandedKeys, o);
      t.flattenNodes = v;
    }
    if (e.selectable && (n("selectedKeys") ? t.selectedKeys = z(e.selectedKeys, e) : !E && e.defaultSelectedKeys && (t.selectedKeys = z(e.defaultSelectedKeys, e))), e.checkable && (n("checkedKeys") ? d = B(e.checkedKeys) || {} : !E && e.defaultCheckedKeys ? d = B(e.defaultCheckedKeys) || {} : m && (d = B(e.checkedKeys) || { checkedKeys: h.checkedKeys, halfCheckedKeys: h.halfCheckedKeys }), d)) {
      var r = d, c = r.checkedKeys, K = c === void 0 ? [] : c, u = r.halfCheckedKeys, f = u === void 0 ? [] : u;
      if (!e.checkStrictly) {
        var N = j(K, !0, i);
        K = N.checkedKeys, f = N.halfCheckedKeys;
      }
      t.checkedKeys = K, t.halfCheckedKeys = f;
    }
    return n("loadedKeys") && (t.loadedKeys = e.loadedKeys), t;
  } }]), I;
}(W.Component);
l(Q, "defaultProps", { prefixCls: "rc-tree", showLine: !1, showIcon: !0, selectable: !0, multiple: !1, checkable: !1, disabled: !1, checkStrictly: !1, draggable: !1, defaultExpandParent: !0, autoExpandParent: !1, defaultExpandAll: !1, defaultExpandedKeys: [], defaultCheckedKeys: [], defaultSelectedKeys: [], dropIndicatorRender: Ce, allowDrop: function() {
  return !0;
}, expandAction: !1 }), l(Q, "TreeNode", Se);
export {
  Q as default
};
