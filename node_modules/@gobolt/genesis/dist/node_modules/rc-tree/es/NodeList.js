import F from "../../@babel/runtime/helpers/esm/extends.js";
import xe from "../../@babel/runtime/helpers/esm/objectDestructuringEmpty.js";
import f from "../../@babel/runtime/helpers/esm/slicedToArray.js";
import Ce from "../../@babel/runtime/helpers/esm/objectWithoutProperties.js";
import Ne from "../../rc-util/es/hooks/useLayoutEffect.js";
import Se from "../../rc-virtual-list/es/List.js";
import * as n from "react";
import Ie from "./MotionTreeNode.js";
import { findExpandedKeys as Me, getExpandRange as B } from "./utils/diffUtil.js";
import { getTreeNodeProps as Re, getKey as Y } from "./utils/treeUtil.js";
var Oe = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "scrollWidth", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"], A = { width: 0, height: 0, display: "flex", overflow: "hidden", opacity: 0, border: 0, padding: 0, margin: 0 }, we = function() {
}, y = "RC_TREE_MOTION_".concat(Math.random()), N = { key: y }, Te = { key: y, level: 0, index: 0, pos: "0", node: N, nodes: [N] }, V = { parent: null, children: [], pos: Te.pos, data: N, title: null, key: y, isStart: [], isEnd: [] };
function j(e, d, r, o) {
  return d !== !1 && r ? e.slice(0, Math.ceil(r / o) + 1) : e;
}
function q(e) {
  var d = e.key, r = e.pos;
  return Y(d, r);
}
var He = n.forwardRef(function(e, d) {
  var r = e.prefixCls, o = e.data;
  e.selectable, e.checkable;
  var s = e.expandedKeys, z = e.selectedKeys, G = e.checkedKeys, J = e.loadedKeys, Q = e.loadingKeys, U = e.halfCheckedKeys, X = e.keyEntities, Z = e.disabled, S = e.dragging, $ = e.dragOverNodeKey, ee = e.dropPosition, I = e.motion, E = e.height, K = e.itemHeight, k = e.virtual, te = e.scrollWidth, M = e.focusable, m = e.activeItem, ne = e.focused, oe = e.tabIndex, ie = e.onKeyDown, ae = e.onFocus, re = e.onBlur, de = e.onActiveChange, se = e.onListChangeStart, le = e.onListChangeEnd, ce = Ce(e, Oe), R = n.useRef(null), O = n.useRef(null);
  n.useImperativeHandle(d, function() {
    return { scrollTo: function(t) {
      R.current.scrollTo(t);
    }, getIndentWidth: function() {
      return O.current.offsetWidth;
    } };
  });
  var ue = n.useState(s), w = f(ue, 2), fe = w[0], ye = w[1], me = n.useState(o), T = f(me, 2), l = T[0], H = T[1], pe = n.useState(o), L = f(pe, 2), ge = L[0], p = L[1], ve = n.useState([]), P = f(ve, 2), Ee = P[0], h = P[1], Ke = n.useState(null), W = f(Ke, 2), ke = W[0], b = W[1], _ = n.useRef(o);
  function x() {
    var t = _.current;
    H(t), p(t), h([]), b(null), le();
  }
  _.current = o, Ne(function() {
    ye(s);
    var t = Me(fe, s);
    if (t.key !== null) if (t.add) {
      var i = l.findIndex(function(u) {
        return u.key === t.key;
      }), a = j(B(l, o, t.key), k, E, K), g = l.slice();
      g.splice(i + 1, 0, V), p(g), h(a), b("show");
    } else {
      var c = o.findIndex(function(u) {
        return u.key === t.key;
      }), C = j(B(o, l, t.key), k, E, K), v = o.slice();
      v.splice(c + 1, 0, V), p(v), h(C), b("hide");
    }
    else l !== o && (H(o), p(o));
  }, [s, o]), n.useEffect(function() {
    S || x();
  }, [S]);
  var he = I ? ge : o, D = { expandedKeys: s, selectedKeys: z, loadedKeys: J, loadingKeys: Q, checkedKeys: G, halfCheckedKeys: U, dragOverNodeKey: $, dropPosition: ee, keyEntities: X };
  return n.createElement(n.Fragment, null, ne && m && n.createElement("span", { style: A, "aria-live": "assertive" }, function(t) {
    for (var i = String(t.data.key), a = t; a.parent; ) a = a.parent, i = "".concat(a.data.key, " > ").concat(i);
    return i;
  }(m)), n.createElement("div", null, n.createElement("input", { style: A, disabled: M === !1 || Z, tabIndex: M !== !1 ? oe : null, onKeyDown: ie, onFocus: ae, onBlur: re, value: "", onChange: we, "aria-label": "for screen reader" })), n.createElement("div", { className: "".concat(r, "-treenode"), "aria-hidden": !0, style: { position: "absolute", pointerEvents: "none", visibility: "hidden", height: 0, overflow: "hidden", border: 0, padding: 0 } }, n.createElement("div", { className: "".concat(r, "-indent") }, n.createElement("div", { ref: O, className: "".concat(r, "-indent-unit") }))), n.createElement(Se, F({}, ce, { data: he, itemKey: q, height: E, fullHeight: !1, virtual: k, itemHeight: K, scrollWidth: te, prefixCls: "".concat(r, "-list"), ref: R, role: "tree", onVisibleChange: function(t) {
    t.every(function(i) {
      return q(i) !== y;
    }) && x();
  } }), function(t) {
    var i = t.pos, a = Object.assign({}, (xe(t.data), t.data)), g = t.title, c = t.key, C = t.isStart, v = t.isEnd, u = Y(c, i);
    delete a.key, delete a.children;
    var be = Re(u, D);
    return n.createElement(Ie, F({}, a, be, { title: g, active: !!m && c === m.key, pos: i, data: t.data, isStart: C, isEnd: v, motion: I, motionNodes: c === y ? Ee : null, motionType: ke, onMotionStart: se, onMotionEnd: x, treeNodeRequiredProps: D, onMouseMove: function() {
      de(null);
    } }));
  }));
});
process.env.NODE_ENV !== "production" && (He.displayName = "NodeList");
export {
  y as MOTION_KEY,
  Te as MotionEntity,
  He as default,
  j as getMinimumRangeTransitionRange
};
