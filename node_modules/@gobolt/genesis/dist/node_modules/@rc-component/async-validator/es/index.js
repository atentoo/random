import y from "../../../@babel/runtime/helpers/esm/objectSpread2.js";
import E from "../../../@babel/runtime/helpers/esm/toConsumableArray.js";
import j from "../../../@babel/runtime/helpers/esm/typeof.js";
import W from "../../../@babel/runtime/helpers/esm/classCallCheck.js";
import z from "../../../@babel/runtime/helpers/esm/createClass.js";
import v from "../../../@babel/runtime/helpers/esm/defineProperty.js";
import { messages as M, newMessages as _ } from "./messages.js";
import { warning as B, deepMerge as C, asyncMap as D, format as P, convertFieldsError as G, complementError as R } from "./util.js";
import b from "./validator/index.js";
var O = function() {
  function g(r) {
    W(this, g), v(this, "rules", null), v(this, "_messages", M), this.define(r);
  }
  return z(g, [{ key: "define", value: function(r) {
    var u = this;
    if (!r) throw new Error("Cannot configure a schema with no rules");
    if (j(r) !== "object" || Array.isArray(r)) throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(r).forEach(function(i) {
      var a = r[i];
      u.rules[i] = Array.isArray(a) ? a : [a];
    });
  } }, { key: "messages", value: function(r) {
    return r && (this._messages = C(_(), r)), this._messages;
  } }, { key: "validate", value: function(r) {
    var u = this, i = r, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
    };
    if (typeof a == "function" && (h = a, a = {}), !this.rules || Object.keys(this.rules).length === 0) return h && h(null, i), Promise.resolve(i);
    if (a.messages) {
      var F = this.messages();
      F === M && (F = _()), C(F, a.messages), a.messages = F;
    } else a.messages = this.messages();
    var k = {};
    (a.keys || Object.keys(this.rules)).forEach(function(t) {
      var c = u.rules[t], n = i[t];
      c.forEach(function(e) {
        var s = e;
        typeof s.transform == "function" && (i === r && (i = y({}, i)), (n = i[t] = s.transform(n)) != null && (s.type = s.type || (Array.isArray(n) ? "array" : j(n)))), (s = typeof s == "function" ? { validator: s } : y({}, s)).validator = u.getValidationMethod(s), s.validator && (s.field = t, s.fullField = s.fullField || t, s.type = u.getType(s), k[t] = k[t] || [], k[t].push({ rule: s, value: n, source: i, field: t }));
      });
    });
    var S = {};
    return D(k, a, function(t, c) {
      var n, e = t.rule, s = !(e.type !== "object" && e.type !== "array" || j(e.fields) !== "object" && j(e.defaultField) !== "object");
      function A(l, p) {
        return y(y({}, p), {}, { fullField: "".concat(e.fullField, ".").concat(l), fullFields: e.fullFields ? [].concat(E(e.fullFields), [l]) : [l] });
      }
      function o() {
        var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], p = Array.isArray(l) ? l : [l];
        !a.suppressWarning && p.length && g.warning("async-validator:", p), p.length && e.message !== void 0 && (p = [].concat(e.message));
        var m = p.map(R(e, i));
        if (a.first && m.length) return S[e.field] = 1, c(m);
        if (s) {
          if (e.required && !t.value) return e.message !== void 0 ? m = [].concat(e.message).map(R(e, i)) : a.error && (m = [a.error(e, P(a.messages.required, e.field))]), c(m);
          var w = {};
          e.defaultField && Object.keys(t.value).map(function(d) {
            w[d] = e.defaultField;
          }), w = y(y({}, w), t.rule.fields);
          var T = {};
          Object.keys(w).forEach(function(d) {
            var f = w[d], U = Array.isArray(f) ? f : [f];
            T[d] = U.map(A.bind(null, d));
          });
          var x = new g(T);
          x.messages(a.messages), t.rule.options && (t.rule.options.messages = a.messages, t.rule.options.error = a.error), x.validate(t.value, t.rule.options || a, function(d) {
            var f = [];
            m && m.length && f.push.apply(f, E(m)), d && d.length && f.push.apply(f, E(d)), c(f.length ? f : null);
          });
        } else c(m);
      }
      if (s = s && (e.required || !e.required && t.value), e.field = t.field, e.asyncValidator) n = e.asyncValidator(e, t.value, o, t.source, a);
      else if (e.validator) {
        try {
          n = e.validator(e, t.value, o, t.source, a);
        } catch (l) {
          var q, V;
          (q = (V = console).error) === null || q === void 0 || q.call(V, l), a.suppressValidatorError || setTimeout(function() {
            throw l;
          }, 0), o(l.message);
        }
        n === !0 ? o() : n === !1 ? o(typeof e.message == "function" ? e.message(e.fullField || e.field) : e.message || "".concat(e.fullField || e.field, " fails")) : n instanceof Array ? o(n) : n instanceof Error && o(n.message);
      }
      n && n.then && n.then(function() {
        return o();
      }, function(l) {
        return o(l);
      });
    }, function(t) {
      (function(c) {
        for (var n, e, s = [], A = {}, o = 0; o < c.length; o++) n = c[o], e = void 0, Array.isArray(n) ? s = (e = s).concat.apply(e, E(n)) : s.push(n);
        s.length ? (A = G(s), h(s, A)) : h(null, i);
      })(t);
    }, i);
  } }, { key: "getType", value: function(r) {
    if (r.type === void 0 && r.pattern instanceof RegExp && (r.type = "pattern"), typeof r.validator != "function" && r.type && !b.hasOwnProperty(r.type)) throw new Error(P("Unknown rule type %s", r.type));
    return r.type || "string";
  } }, { key: "getValidationMethod", value: function(r) {
    if (typeof r.validator == "function") return r.validator;
    var u = Object.keys(r), i = u.indexOf("message");
    return i !== -1 && u.splice(i, 1), u.length === 1 && u[0] === "required" ? b.required : b[this.getType(r)] || void 0;
  } }]), g;
}();
v(O, "register", function(g, r) {
  if (typeof r != "function") throw new Error("Cannot register a validator by type, validator is not a function");
  b[g] = r;
}), v(O, "warning", B), v(O, "messages", M), v(O, "validators", b);
export {
  O as default
};
