import K from "../../../../../@babel/runtime/helpers/esm/toConsumableArray.js";
import * as b from "react";
import { devUseWarning as D } from "../../../_util/warning.js";
import { getColumnKey as O, getColumnPos as S, renderColumnTitle as E } from "../../util.js";
import P, { flattenKeys as v } from "./FilterDropdown.js";
const M = (s, r, c) => {
  let i = [];
  return (s || []).forEach((e, u) => {
    var n;
    const f = S(u, c);
    if (e.filters || "filterDropdown" in e || "onFilter" in e) if ("filteredValue" in e) {
      let t = e.filteredValue;
      "filterDropdown" in e || (t = (n = t == null ? void 0 : t.map(String)) !== null && n !== void 0 ? n : t), i.push({ column: e, key: O(e, f), filteredKeys: t, forceFiltered: e.filtered });
    } else i.push({ column: e, key: O(e, f), filteredKeys: r && e.defaultFilteredValue ? e.defaultFilteredValue : void 0, forceFiltered: e.filtered });
    "children" in e && (i = [].concat(K(i), K(M(e.children, r, f))));
  }), i;
};
function x(s, r, c, i, e, u, n, f, t) {
  return c.map((o, m) => {
    const y = S(m, f), { filterOnClose: g = !0, filterMultiple: F = !0, filterMode: j, filterSearch: d } = o;
    let l = o;
    if (l.filters || l.filterDropdown) {
      const C = O(l, y), p = i.find((a) => {
        let { key: h } = a;
        return C === h;
      });
      l = Object.assign(Object.assign({}, l), { title: (a) => b.createElement(P, { tablePrefixCls: s, prefixCls: `${s}-filter`, dropdownPrefixCls: r, column: l, columnKey: C, filterState: p, filterOnClose: g, filterMultiple: F, filterMode: j, filterSearch: d, triggerFilter: u, locale: e, getPopupContainer: n, rootClassName: t }, E(o.title, a)) });
    }
    return "children" in l && (l = Object.assign(Object.assign({}, l), { children: x(s, r, l.children, i, e, u, n, y, t) })), l;
  });
}
const k = (s) => {
  const r = {};
  return s.forEach((c) => {
    let { key: i, filteredKeys: e, column: u } = c;
    const n = i, { filters: f, filterDropdown: t } = u;
    if (t) r[n] = e || null;
    else if (Array.isArray(e)) {
      const o = v(f);
      r[n] = o.filter((m) => e.includes(String(m)));
    } else r[n] = null;
  }), r;
}, N = (s, r, c) => r.reduce((i, e) => {
  const { column: { onFilter: u, filters: n }, filteredKeys: f } = e;
  return u && f && f.length ? i.map((t) => Object.assign({}, t)).filter((t) => f.some((o) => {
    const m = v(n), y = m.findIndex((F) => String(F) === String(o)), g = y !== -1 ? m[y] : o;
    return t[c] && (t[c] = N(t[c], r, c)), u(g, t);
  })) : i;
}, s), V = (s) => s.flatMap((r) => "children" in r ? [r].concat(K(V(r.children || []))) : [r]), W = (s) => {
  const { prefixCls: r, dropdownPrefixCls: c, mergedColumns: i, onFilterChange: e, getPopupContainer: u, locale: n, rootClassName: f } = s, t = D("Table"), o = b.useMemo(() => V(i || []), [i]), [m, y] = b.useState(() => M(o, !0)), g = b.useMemo(() => {
    const d = M(o, !1);
    if (d.length === 0) return d;
    let l = !0, C = !0;
    if (d.forEach((p) => {
      let { filteredKeys: a } = p;
      a !== void 0 ? l = !1 : C = !1;
    }), l) {
      const p = (o || []).map((a, h) => O(a, S(h)));
      return m.filter((a) => {
        let { key: h } = a;
        return p.includes(h);
      }).map((a) => {
        const h = o[p.findIndex((w) => w === a.key)];
        return Object.assign(Object.assign({}, a), { column: Object.assign(Object.assign({}, a.column), h), forceFiltered: h.filtered });
      });
    }
    return process.env.NODE_ENV !== "production" && t(C, "usage", "Columns should all contain `filteredValue` or not contain `filteredValue`."), d;
  }, [o, m]), F = b.useMemo(() => k(g), [g]), j = (d) => {
    const l = g.filter((C) => {
      let { key: p } = C;
      return p !== d.key;
    });
    l.push(d), y(l), e(k(l), l);
  };
  return [(d) => x(r, c, d, g, n, j, u, void 0, f), g, F];
};
export {
  W as default,
  v as flattenKeys,
  N as getFilterData
};
