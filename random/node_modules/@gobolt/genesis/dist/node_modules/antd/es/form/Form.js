import * as e from "react";
import U from "../../../../_virtual/index.js";
import X from "../../../rc-field-form/es/index.js";
import { useComponentConfig as Y } from "../config-provider/context.js";
import Z, { DisabledContextProvider as ee } from "../config-provider/DisabledContext.js";
import re from "../config-provider/hooks/useCSSVarCls.js";
import oe from "../config-provider/hooks/useSize.js";
import le from "../config-provider/SizeContext.js";
import { VariantContext as ae, FormProvider as te, FormContext as ie } from "./context.js";
import se from "./hooks/useForm.js";
import ne from "./hooks/useFormWarning.js";
import me from "./style/index.js";
import ce from "./validateMessagesContext.js";
var de = function(o, m) {
  var s = {};
  for (var r in o) Object.prototype.hasOwnProperty.call(o, r) && m.indexOf(r) < 0 && (s[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function") {
    var a = 0;
    for (r = Object.getOwnPropertySymbols(o); a < r.length; a++) m.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[a]) && (s[r[a]] = o[r[a]]);
  }
  return s;
};
const fe = (o, m) => {
  const s = e.useContext(Z), { getPrefixCls: r, direction: a, requiredMark: d, colon: q, scrollToFirstError: C, className: w, style: I } = Y("form"), { prefixCls: R, className: T, rootClassName: $, size: A, disabled: z = s, form: D, colon: F, labelAlign: O, labelWrap: V, labelCol: g, wrapperCol: y, hideRequiredMark: E, layout: f = "horizontal", scrollToFirstError: N, requiredMark: p, onFinishFailed: j, name: n, style: W, feedbackIcons: k, variant: S } = o, H = de(o, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name", "style", "feedbackIcons", "variant"]), u = oe(A), L = e.useContext(ce);
  process.env.NODE_ENV !== "production" && ne(o);
  const b = e.useMemo(() => p !== void 0 ? p : !E && (d === void 0 || d), [E, p, d]), x = F ?? q, t = r("form", R), h = re(t), [B, G, J] = me(t, h), K = U(t, `${t}-${f}`, { [`${t}-hide-required-mark`]: b === !1, [`${t}-rtl`]: a === "rtl", [`${t}-${u}`]: u }, J, h, G, w, T, $), [i] = se(D), { __INTERNAL__: M } = i;
  M.name = n;
  const Q = e.useMemo(() => ({ name: n, labelAlign: O, labelCol: g, labelWrap: V, wrapperCol: y, vertical: f === "vertical", colon: x, requiredMark: b, itemRef: M.itemRef, form: i, feedbackIcons: k }), [n, O, g, y, f, x, b, i, k]), P = e.useRef(null);
  e.useImperativeHandle(m, () => {
    var l;
    return Object.assign(Object.assign({}, i), { nativeElement: (l = P.current) === null || l === void 0 ? void 0 : l.nativeElement });
  });
  const _ = (l, c) => {
    if (l) {
      let v = { block: "nearest" };
      typeof l == "object" && (v = Object.assign(Object.assign({}, v), l)), i.scrollToField(c, v);
    }
  };
  return B(e.createElement(ae.Provider, { value: S }, e.createElement(ee, { disabled: z }, e.createElement(le.Provider, { value: u }, e.createElement(te, { validateMessages: L }, e.createElement(ie.Provider, { value: Q }, e.createElement(X, Object.assign({ id: n }, H, { name: n, onFinishFailed: (l) => {
    if (j == null || j(l), l.errorFields.length) {
      const c = l.errorFields[0].name;
      if (N !== void 0) return void _(N, c);
      C !== void 0 && _(C, c);
    }
  }, form: i, ref: P, style: Object.assign(Object.assign({}, I), W), className: K }))))))));
}, pe = e.forwardRef(fe);
process.env.NODE_ENV !== "production" && (pe.displayName = "Form");
export {
  pe as default,
  se as useForm
};
