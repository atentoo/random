import D from "../../../../@babel/runtime/helpers/esm/toConsumableArray.js";
import * as b from "react";
import Q from "../../../../@ant-design/icons/es/icons/CaretDownOutlined.js";
import U from "../../../../@ant-design/icons/es/icons/CaretUpOutlined.js";
import k from "../../../../../_virtual/index.js";
import V from "../../../../rc-util/es/KeyCode.js";
import L from "../../tooltip/index.js";
import { getColumnKey as T, safeColumnTitle as W, renderColumnTitle as X, getColumnPos as M } from "../util.js";
const w = "ascend", K = "descend", x = (r) => typeof r.sorter == "object" && typeof r.sorter.multiple == "number" && r.sorter.multiple, R = (r) => typeof r == "function" ? r : !(!r || typeof r != "object" || !r.compare) && r.compare, A = (r, i, l) => {
  let p = [];
  const S = (t, c) => {
    p.push({ column: t, key: T(t, c), multiplePriority: x(t), sortOrder: t.sortOrder });
  };
  return (r || []).forEach((t, c) => {
    const a = M(c, l);
    t.children ? ("sortOrder" in t && S(t, a), p = [].concat(D(p), D(A(t.children, i, a)))) : t.sorter && ("sortOrder" in t ? S(t, a) : i && t.defaultSortOrder && p.push({ column: t, key: T(t, a), multiplePriority: x(t), sortOrder: t.defaultSortOrder }));
  }), p;
}, B = (r, i, l, p, S, t, c, a) => (i || []).map((o, j) => {
  const y = M(j, a);
  let s = o;
  if (s.sorter) {
    const v = s.sortDirections || S, e = s.showSorterTooltip === void 0 ? c : s.showSorterTooltip, m = T(s, y), d = l.find((h) => {
      let { key: f } = h;
      return f === m;
    }), u = d ? d.sortOrder : null, O = ((h, f) => f ? h[h.indexOf(f) + 1] : h[0])(v, u);
    let n;
    if (o.sortIcon) n = o.sortIcon({ sortOrder: u });
    else {
      const h = v.includes(w) && b.createElement(U, { className: k(`${r}-column-sorter-up`, { active: u === w }) }), f = v.includes(K) && b.createElement(Q, { className: k(`${r}-column-sorter-down`, { active: u === K }) });
      n = b.createElement("span", { className: k(`${r}-column-sorter`, { [`${r}-column-sorter-full`]: !(!h || !f) }) }, b.createElement("span", { className: `${r}-column-sorter-inner`, "aria-hidden": "true" }, h, f));
    }
    const { cancelSort: C, triggerAsc: I, triggerDesc: G } = t || {};
    let N = C;
    O === K ? N = G : O === w && (N = I);
    const F = typeof e == "object" ? Object.assign({ title: N }, e) : { title: N };
    s = Object.assign(Object.assign({}, s), { className: k(s.className, { [`${r}-column-sort`]: u }), title: (h) => {
      const f = `${r}-column-sorters`, g = b.createElement("span", { className: `${r}-column-title` }, X(o.title, h)), E = b.createElement("div", { className: f }, g, n);
      return e ? typeof e != "boolean" && (e == null ? void 0 : e.target) === "sorter-icon" ? b.createElement("div", { className: `${f} ${r}-column-sorters-tooltip-target-sorter` }, g, b.createElement(L, Object.assign({}, F), n)) : b.createElement(L, Object.assign({}, F), E) : E;
    }, onHeaderCell: (h) => {
      var f;
      const g = ((f = o.onHeaderCell) === null || f === void 0 ? void 0 : f.call(o, h)) || {}, E = g.onClick, H = g.onKeyDown;
      g.onClick = ($) => {
        p({ column: o, key: m, sortOrder: O, multiplePriority: x(o) }), E == null || E($);
      }, g.onKeyDown = ($) => {
        $.keyCode === V.ENTER && (p({ column: o, key: m, sortOrder: O, multiplePriority: x(o) }), H == null || H($));
      };
      const P = W(o.title, {}), J = P == null ? void 0 : P.toString();
      return u && (g["aria-sort"] = u === "ascend" ? "ascending" : "descending"), g["aria-label"] = J || "", g.className = k(g.className, `${r}-column-has-sorters`), g.tabIndex = 0, o.ellipsis && (g.title = (P ?? "").toString()), g;
    } });
  }
  return "children" in s && (s = Object.assign(Object.assign({}, s), { children: B(r, s.children, l, p, S, t, c, y) })), s;
}), q = (r) => {
  const { column: i, sortOrder: l } = r;
  return { column: i, order: l, field: i.dataIndex, columnKey: i.key };
}, z = (r) => {
  const i = r.filter((l) => {
    let { sortOrder: p } = l;
    return p;
  }).map(q);
  if (i.length === 0 && r.length) {
    const l = r.length - 1;
    return Object.assign(Object.assign({}, q(r[l])), { column: void 0, order: void 0, field: void 0, columnKey: void 0 });
  }
  return i.length <= 1 ? i[0] || {} : i;
}, Y = (r, i, l) => {
  const p = i.slice().sort((c, a) => a.multiplePriority - c.multiplePriority), S = r.slice(), t = p.filter((c) => {
    let { column: { sorter: a }, sortOrder: o } = c;
    return R(a) && o;
  });
  return t.length ? S.sort((c, a) => {
    for (let o = 0; o < t.length; o += 1) {
      const j = t[o], { column: { sorter: y }, sortOrder: s } = j, v = R(y);
      if (v && s) {
        const e = v(c, a, s);
        if (e !== 0) return s === w ? e : -e;
      }
    }
    return 0;
  }).map((c) => {
    const a = c[l];
    return a ? Object.assign(Object.assign({}, c), { [l]: Y(a, i, l) }) : c;
  }) : S;
}, lr = (r) => {
  const { prefixCls: i, mergedColumns: l, sortDirections: p, tableLocale: S, showSorterTooltip: t, onSorterChange: c } = r, [a, o] = b.useState(A(l, !0)), j = (e, m) => {
    const d = [];
    return e.forEach((u, O) => {
      const n = M(O, m);
      if (d.push(T(u, n)), Array.isArray(u.children)) {
        const C = j(u.children, n);
        d.push.apply(d, D(C));
      }
    }), d;
  }, y = b.useMemo(() => {
    let e = !0;
    const m = A(l, !1);
    if (!m.length) {
      const n = j(l);
      return a.filter((C) => {
        let { key: I } = C;
        return n.includes(I);
      });
    }
    const d = [];
    function u(n) {
      e ? d.push(n) : d.push(Object.assign(Object.assign({}, n), { sortOrder: null }));
    }
    let O = null;
    return m.forEach((n) => {
      O === null ? (u(n), n.sortOrder && (n.multiplePriority === !1 ? e = !1 : O = !0)) : (O && n.multiplePriority !== !1 || (e = !1), u(n));
    }), d;
  }, [l, a]), s = b.useMemo(() => {
    var e, m;
    const d = y.map((u) => {
      let { column: O, sortOrder: n } = u;
      return { column: O, order: n };
    });
    return { sortColumns: d, sortColumn: (e = d[0]) === null || e === void 0 ? void 0 : e.column, sortOrder: (m = d[0]) === null || m === void 0 ? void 0 : m.order };
  }, [y]), v = (e) => {
    let m;
    m = e.multiplePriority !== !1 && y.length && y[0].multiplePriority !== !1 ? [].concat(D(y.filter((d) => {
      let { key: u } = d;
      return u !== e.key;
    })), [e]) : [e], o(m), c(z(m), m);
  };
  return [(e) => B(i, e, y, v, p, S, t), y, s, () => z(y)];
};
export {
  lr as default,
  Y as getSortData
};
