import T from "../../../../@babel/runtime/helpers/esm/toConsumableArray.js";
import * as C from "react";
import { useCallback as q, useMemo as I } from "react";
import We from "../../../../@ant-design/icons/es/icons/DownOutlined.js";
import Xe from "../../../../../_virtual/index.js";
import "../../../../rc-table/es/Footer/index.js";
import "../../../../rc-table/es/Table.js";
import { INTERNAL_COL_DEFINE as ue } from "../../../../rc-table/es/utils/legacyUtil.js";
import "../../../../rc-table/es/VirtualTable/index.js";
import { arrDel as Be, arrAdd as Fe } from "../../../../rc-tree/es/util.js";
import { conductCheck as me } from "../../../../rc-tree/es/utils/conductUtil.js";
import { convertDataToEntities as qe } from "../../../../rc-tree/es/utils/treeUtil.js";
import ze from "../../../../rc-util/es/hooks/useMergedState.js";
import He from "../../_util/hooks/useMultipleSelect.js";
import { devUseWarning as Je } from "../../_util/warning.js";
import Le from "../../checkbox/index.js";
import Qe from "../../dropdown/index.js";
import Ye from "../../radio/index.js";
const S = {}, Ae = "SELECT_ALL", _e = "SELECT_INVERT", xe = "SELECT_NONE", Ie = [], Ke = (U, h) => {
  let v = [];
  return (h || []).forEach((O) => {
    v.push(O), O && typeof O == "object" && U in O && (v = [].concat(T(v), T(Ke(U, O[U]))));
  }), v;
}, vt = (U, h) => {
  const { preserveSelectedRowKeys: v, selectedRowKeys: O, defaultSelectedRowKeys: De, getCheckboxProps: V, onChange: Y, onSelect: Z, onSelectAll: pe, onSelectInvert: ee, onSelectNone: fe, onSelectMultiple: te, columnWidth: he, type: L, selections: $, fixed: Pe, renderCell: ve, hideSelectAll: Ee, checkStrictly: K = !0 } = h || {}, { prefixCls: G, data: ne, pageData: z, getRecordByKey: E, getRowKey: p, expandType: ge, childrenColumnName: H, locale: le, getPopupContainer: Ce } = U, W = Je("Table"), [Me, oe] = He((t) => t), [X, re] = ze(O || De || Ie, { value: O }), B = C.useRef(/* @__PURE__ */ new Map()), ye = q((t) => {
    if (v) {
      const l = /* @__PURE__ */ new Map();
      t.forEach((e) => {
        let n = E(e);
        !n && B.current.has(e) && (n = B.current.get(e)), l.set(e, n);
      }), B.current = l;
    }
  }, [E, v]);
  C.useEffect(() => {
    ye(X);
  }, [X]);
  const y = I(() => Ke(H, z), [H, z]), { keyEntities: J } = I(() => {
    if (K) return { keyEntities: null };
    let t = ne;
    if (v) {
      const l = new Set(y.map((n, r) => p(n, r))), e = Array.from(B.current).reduce((n, r) => {
        let [d, P] = r;
        return l.has(d) ? n : n.concat(P);
      }, []);
      t = [].concat(T(t), T(e));
    }
    return qe(t, { externalGetKey: p, childrenPropName: H });
  }, [ne, p, K, H, v, y]), g = I(() => {
    const t = /* @__PURE__ */ new Map();
    return y.forEach((l, e) => {
      const n = p(l, e), r = (V ? V(l) : null) || {};
      t.set(n, r), process.env.NODE_ENV !== "production" && W(!("checked" in r || "defaultChecked" in r), "usage", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.");
    }), t;
  }, [y, p, V]), F = q((t) => {
    const l = p(t);
    let e;
    return e = g.has(l) ? g.get(p(t)) : V ? V(t) : void 0, !!(e != null && e.disabled);
  }, [g, p]), [D, ke] = I(() => {
    if (K) return [X || [], []];
    const { checkedKeys: t, halfCheckedKeys: l } = me(X, !0, J, F);
    return [t || [], l];
  }, [X, K, J, F]), A = I(() => {
    const t = L === "radio" ? D.slice(0, 1) : D;
    return new Set(t);
  }, [D, L]), Ne = I(() => L === "radio" ? /* @__PURE__ */ new Set() : new Set(ke), [ke, L]);
  C.useEffect(() => {
    h || re(Ie);
  }, [!!h]);
  const b = q((t, l) => {
    let e, n;
    ye(t), v ? (e = t, n = t.map((r) => B.current.get(r))) : (e = [], n = [], t.forEach((r) => {
      const d = E(r);
      d !== void 0 && (e.push(r), n.push(d));
    })), re(e), Y == null || Y(e, n, { type: l });
  }, [re, E, Y, v]), Q = q((t, l, e, n) => {
    if (Z) {
      const r = e.map((d) => E(d));
      Z(E(t), l, r, n);
    }
    b(e, "single");
  }, [Z, E, b]), ce = I(() => !$ || Ee ? null : ($ === !0 ? [Ae, _e, xe] : $).map((t) => t === Ae ? { key: "all", text: le.selectionAll, onSelect() {
    b(ne.map((l, e) => p(l, e)).filter((l) => {
      const e = g.get(l);
      return !(e != null && e.disabled) || A.has(l);
    }), "all");
  } } : t === _e ? { key: "invert", text: le.selectInvert, onSelect() {
    const l = new Set(A);
    z.forEach((n, r) => {
      const d = p(n, r), P = g.get(d);
      P != null && P.disabled || (l.has(d) ? l.delete(d) : l.add(d));
    });
    const e = Array.from(l);
    ee && (W.deprecated(!1, "onSelectInvert", "onChange"), ee(e)), b(e, "invert");
  } } : t === xe ? { key: "none", text: le.selectNone, onSelect() {
    fe == null || fe(), b(Array.from(A).filter((l) => {
      const e = g.get(l);
      return e == null ? void 0 : e.disabled;
    }), "none");
  } } : t).map((t) => Object.assign(Object.assign({}, t), { onSelect: function() {
    for (var l, e, n = arguments.length, r = new Array(n), d = 0; d < n; d++) r[d] = arguments[d];
    (e = t.onSelect) === null || e === void 0 || (l = e).call.apply(l, [t].concat(r)), oe(null);
  } })), [$, A, z, p, ee, b]);
  return [q((t) => {
    var l;
    if (!h) return process.env.NODE_ENV !== "production" && W(!t.includes(S), "usage", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`."), t.filter((o) => o !== S);
    let e = T(t);
    const n = new Set(A), r = y.map(p).filter((o) => !g.get(o).disabled), d = r.every((o) => n.has(o)), P = r.some((o) => n.has(o)), Re = () => {
      const o = [];
      d ? r.forEach((i) => {
        n.delete(i), o.push(i);
      }) : r.forEach((i) => {
        n.has(i) || (n.add(i), o.push(i));
      });
      const s = Array.from(n);
      pe == null || pe(!d, s.map((i) => E(i)), o.map((i) => E(i))), b(s, "all"), oe(null);
    };
    let Se, ae, Oe;
    if (L !== "radio") {
      let o;
      if (ce) {
        const c = { getPopupContainer: Ce, items: ce.map((u, a) => {
          const { key: w, text: x, onSelect: k } = u;
          return { key: w ?? a, onClick: () => {
            k == null || k(r);
          }, label: x };
        }) };
        o = C.createElement("div", { className: `${G}-selection-extra` }, C.createElement(Qe, { menu: c, getPopupContainer: Ce }, C.createElement("span", null, C.createElement(We, null))));
      }
      const s = y.map((c, u) => {
        const a = p(c, u), w = g.get(a) || {};
        return Object.assign({ checked: n.has(a) }, w);
      }).filter((c) => {
        let { disabled: u } = c;
        return u;
      }), i = !!s.length && s.length === y.length, f = i && s.every((c) => {
        let { checked: u } = c;
        return u;
      }), m = i && s.some((c) => {
        let { checked: u } = c;
        return u;
      });
      ae = C.createElement(Le, { checked: i ? f : !!y.length && d, indeterminate: i ? !f && m : !d && P, onChange: Re, disabled: y.length === 0 || i, "aria-label": o ? "Custom selection" : "Select all", skipGroup: !0 }), Se = !Ee && C.createElement("div", { className: `${G}-selection` }, ae, o);
    }
    if (Oe = L === "radio" ? (o, s, i) => {
      const f = p(s, i), m = n.has(f), c = g.get(f);
      return { node: C.createElement(Ye, Object.assign({}, c, { checked: m, onClick: (u) => {
        var a;
        u.stopPropagation(), (a = c == null ? void 0 : c.onClick) === null || a === void 0 || a.call(c, u);
      }, onChange: (u) => {
        var a;
        n.has(f) || Q(f, !0, [f], u.nativeEvent), (a = c == null ? void 0 : c.onChange) === null || a === void 0 || a.call(c, u);
      } })), checked: m };
    } : (o, s, i) => {
      var f;
      const m = p(s, i), c = n.has(m), u = Ne.has(m), a = g.get(m);
      let w;
      return ge === "nest" ? (w = u, process.env.NODE_ENV !== "production" && W(typeof (a == null ? void 0 : a.indeterminate) != "boolean", "usage", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.")) : w = (f = a == null ? void 0 : a.indeterminate) !== null && f !== void 0 ? f : u, { node: C.createElement(Le, Object.assign({}, a, { indeterminate: w, checked: c, skipGroup: !0, onClick: (x) => {
        var k;
        x.stopPropagation(), (k = a == null ? void 0 : a.onClick) === null || k === void 0 || k.call(a, x);
      }, onChange: (x) => {
        var k;
        const { nativeEvent: de } = x, { shiftKey: Ve } = de, be = r.findIndex((N) => N === m), $e = D.some((N) => r.includes(N));
        if (Ve && K && $e) {
          const N = Me(be, r, n), R = Array.from(n);
          te == null || te(!c, R.map((j) => E(j)), N.map((j) => E(j))), b(R, "multiple");
        } else {
          const N = D;
          if (K) {
            const R = c ? Be(N, m) : Fe(N, m);
            Q(m, !c, R, de);
          } else {
            const R = me([].concat(T(N), [m]), !0, J, F), { checkedKeys: j, halfCheckedKeys: Ge } = R;
            let we = j;
            if (c) {
              const Te = new Set(j);
              Te.delete(m), we = me(Array.from(Te), { halfCheckedKeys: Ge }, J, F).checkedKeys;
            }
            Q(m, !c, we, de);
          }
        }
        oe(c ? null : be), (k = a == null ? void 0 : a.onChange) === null || k === void 0 || k.call(a, x);
      } })), checked: c };
    }, !e.includes(S)) if (e.findIndex((o) => {
      var s;
      return ((s = o[ue]) === null || s === void 0 ? void 0 : s.columnType) === "EXPAND_COLUMN";
    }) === 0) {
      const [o, ...s] = e;
      e = [o, S].concat(T(s));
    } else e = [S].concat(T(e));
    const ie = e.indexOf(S);
    process.env.NODE_ENV !== "production" && W(e.filter((o) => o === S).length <= 1, "usage", "Multiple `SELECTION_COLUMN` exist in `columns`."), e = e.filter((o, s) => o !== S || s === ie);
    const _ = e[ie - 1], se = e[ie + 1];
    let M = Pe;
    M === void 0 && ((se == null ? void 0 : se.fixed) !== void 0 ? M = se.fixed : (_ == null ? void 0 : _.fixed) !== void 0 && (M = _.fixed)), M && _ && ((l = _[ue]) === null || l === void 0 ? void 0 : l.columnType) === "EXPAND_COLUMN" && _.fixed === void 0 && (_.fixed = M);
    const je = Xe(`${G}-selection-col`, { [`${G}-selection-col-with-dropdown`]: $ && L === "checkbox" }), Ue = { fixed: M, width: he, className: `${G}-selection-column`, title: h != null && h.columnTitle ? typeof h.columnTitle == "function" ? h.columnTitle(ae) : h.columnTitle : Se, render: (o, s, i) => {
      const { node: f, checked: m } = Oe(o, s, i);
      return ve ? ve(m, s, i, f) : f;
    }, onCell: h.onCell, [ue]: { className: je } };
    return e.map((o) => o === S ? Ue : o);
  }, [p, y, h, D, A, Ne, he, ce, ge, g, te, Q, F]), A];
};
export {
  Ae as SELECTION_ALL,
  S as SELECTION_COLUMN,
  _e as SELECTION_INVERT,
  xe as SELECTION_NONE,
  vt as default
};
