import * as i from "react";
import { forwardRef as L } from "react";
import f from "../../../../_virtual/index.js";
import Q from "../../../rc-textarea/es/TextArea.js";
import "../../../rc-resize-observer/es/index.js";
import "../../../rc-util/es/hooks/useLayoutEffect.js";
import "../../../rc-util/es/raf.js";
import X from "../_util/getAllowClear.js";
import { getStatusClassNames as Y, getMergedStatus as Z } from "../_util/statusUtils.js";
import { devUseWarning as ee } from "../_util/warning.js";
import { useComponentConfig as te } from "../config-provider/context.js";
import re from "../config-provider/DisabledContext.js";
import ae from "../config-provider/hooks/useCSSVarCls.js";
import se from "../config-provider/hooks/useSize.js";
import { FormItemInputContext as oe } from "../form/context.js";
import le from "../form/hooks/useVariants.js";
import { useCompactItemContext as ie } from "../space/Compact.js";
import "./Input.js";
import { useSharedStyle as ne } from "./style/index.js";
import me from "./style/textarea.js";
import { triggerFocus as pe } from "../../../rc-input/es/utils/commonUtils.js";
var fe = function(t, n) {
  var o = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (o[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") {
    var s = 0;
    for (r = Object.getOwnPropertySymbols(t); s < r.length; s++) n.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (o[r[s]] = t[r[s]]);
  }
  return o;
};
const Pe = L((t, n) => {
  var o;
  const { prefixCls: r, bordered: s = !0, size: x, disabled: b, status: N, allowClear: v, classNames: c, rootClassName: g, className: j, style: $, styles: h, variant: A } = t, I = fe(t, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const { deprecated: l } = ee("TextArea");
    l(!("bordered" in t), "bordered", "variant");
  }
  const { getPrefixCls: S, direction: C, allowClear: z, autoComplete: E, className: P, style: T, classNames: y, styles: F } = te("textArea"), _ = i.useContext(re), k = b ?? _, { status: R, hasFeedback: W, feedbackIcon: D } = i.useContext(oe), H = Z(R, N), m = i.useRef(null);
  i.useImperativeHandle(n, () => {
    var l;
    return { resizableTextArea: (l = m.current) === null || l === void 0 ? void 0 : l.resizableTextArea, focus: (a) => {
      var u, d;
      pe((d = (u = m.current) === null || u === void 0 ? void 0 : u.resizableTextArea) === null || d === void 0 ? void 0 : d.textArea, a);
    }, blur: () => {
      var a;
      return (a = m.current) === null || a === void 0 ? void 0 : a.blur();
    } };
  });
  const e = S("input", r), O = ae(e), [M, w, U] = ne(e, g), [V] = me(e, O), { compactSize: q, compactItemClassnames: B } = ie(e, C), p = se((l) => {
    var a;
    return (a = x ?? q) !== null && a !== void 0 ? a : l;
  }), [G, J] = le("textArea", A, s), K = X(v ?? z);
  return M(V(i.createElement(Q, Object.assign({ autoComplete: E }, I, { style: Object.assign(Object.assign({}, T), $), styles: Object.assign(Object.assign({}, F), h), disabled: k, allowClear: K, className: f(U, O, j, g, B, P), classNames: Object.assign(Object.assign(Object.assign({}, c), y), { textarea: f({ [`${e}-sm`]: p === "small", [`${e}-lg`]: p === "large" }, w, c == null ? void 0 : c.textarea, y.textarea), variant: f({ [`${e}-${G}`]: J }, Y(e, H)), affixWrapper: f(`${e}-textarea-affix-wrapper`, { [`${e}-affix-wrapper-rtl`]: C === "rtl", [`${e}-affix-wrapper-sm`]: p === "small", [`${e}-affix-wrapper-lg`]: p === "large", [`${e}-textarea-show-count`]: t.showCount || ((o = t.count) === null || o === void 0 ? void 0 : o.show) }, w) }), prefixCls: e, suffix: W && i.createElement("span", { className: `${e}-textarea-suffix` }, D), ref: m }))));
});
export {
  Pe as default
};
