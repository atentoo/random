import { getArrowOffsetToken as g } from "../style/placementArrow.js";
function m(p, a, n, s) {
  if (s === !1) return { adjustX: !1, adjustY: !1 };
  const f = s && typeof s == "object" ? s : {}, o = {};
  switch (p) {
    case "top":
    case "bottom":
      o.shiftX = 2 * a.arrowOffsetHorizontal + n, o.shiftY = !0, o.adjustY = !0;
      break;
    case "left":
    case "right":
      o.shiftY = 2 * a.arrowOffsetVertical + n, o.shiftX = !0, o.adjustX = !0;
  }
  const r = Object.assign(Object.assign({}, o), f);
  return r.shiftX || (r.adjustX = !0), r.shiftY || (r.adjustY = !0), r;
}
const l = { left: { points: ["cr", "cl"] }, right: { points: ["cl", "cr"] }, top: { points: ["bc", "tc"] }, bottom: { points: ["tc", "bc"] }, topLeft: { points: ["bl", "tl"] }, leftTop: { points: ["tr", "tl"] }, topRight: { points: ["br", "tr"] }, rightTop: { points: ["tl", "tr"] }, bottomRight: { points: ["tr", "br"] }, rightBottom: { points: ["bl", "br"] }, bottomLeft: { points: ["tl", "bl"] }, leftBottom: { points: ["br", "bl"] } }, u = { topLeft: { points: ["bl", "tc"] }, leftTop: { points: ["tr", "cl"] }, topRight: { points: ["br", "tc"] }, rightTop: { points: ["tl", "cr"] }, bottomRight: { points: ["tr", "bc"] }, rightBottom: { points: ["bl", "cr"] }, bottomLeft: { points: ["tl", "bc"] }, leftBottom: { points: ["br", "cl"] } }, w = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function d(p) {
  const { arrowWidth: a, autoAdjustOverflow: n, arrowPointAtCenter: s, offset: f, borderRadius: o, visibleFirst: r } = p, e = a / 2, b = {};
  return Object.keys(l).forEach((i) => {
    const h = s && u[i] || l[i], t = Object.assign(Object.assign({}, h), { offset: [0, 0], dynamicInset: !0 });
    switch (b[i] = t, w.has(i) && (t.autoArrow = !1), i) {
      case "top":
      case "topLeft":
      case "topRight":
        t.offset[1] = -e - f;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        t.offset[1] = e + f;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        t.offset[0] = -e - f;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        t.offset[0] = e + f;
    }
    const c = g({ contentRadius: o, limitVerticalRadius: !0 });
    if (s) switch (i) {
      case "topLeft":
      case "bottomLeft":
        t.offset[0] = -c.arrowOffsetHorizontal - e;
        break;
      case "topRight":
      case "bottomRight":
        t.offset[0] = c.arrowOffsetHorizontal + e;
        break;
      case "leftTop":
      case "rightTop":
        t.offset[1] = 2 * -c.arrowOffsetHorizontal + e;
        break;
      case "leftBottom":
      case "rightBottom":
        t.offset[1] = 2 * c.arrowOffsetHorizontal - e;
    }
    t.overflow = m(i, c, a, n), r && (t.htmlRegion = "visibleFirst");
  }), b;
}
export {
  d as default,
  m as getOverflowOptions
};
