import * as n from "react";
import j from "../../../../_virtual/index.js";
import ve from "../../../rc-tooltip/es/Tooltip.js";
import be from "../../../rc-util/es/hooks/useMergedState.js";
import ge from "../_util/ContextIsolator.js";
import { useZIndex as Ce } from "../_util/hooks/useZIndex.js";
import { getTransitionName as Oe } from "../_util/motion.js";
import Ne from "../_util/placements.js";
import { isFragment as we, cloneElement as Pe } from "../_util/reactNode.js";
import { devUseWarning as Ee } from "../_util/warning.js";
import Ae from "../_util/zindexContext.js";
import "../../../@ant-design/cssinjs/es/extractStyle.js";
import "../../../@ant-design/cssinjs/es/hooks/useCacheToken.js";
import "../../../@ant-design/cssinjs/es/StyleContext.js";
import "../../../@ant-design/cssinjs/es/theme/createTheme.js";
import "../../../rc-util/es/warning.js";
import "../../../@ant-design/cssinjs/es/theme/ThemeCache.js";
import "../../../@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js";
import "../../../@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js";
import "../../../@ant-design/cssinjs/es/hooks/useHMR.js";
import "../../../@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js";
import "../../../rc-util/es/ref.js";
import "../../../@ant-design/cssinjs-utils/es/util/statistic.js";
import "../../../@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js";
import he from "../theme/useToken.js";
import je from "./PurePanel.js";
import Ve from "./style/index.js";
import { parseColor as De } from "./util.js";
import { useComponentConfig as Se } from "../config-provider/context.js";
var Te = function(e, c) {
  var s = {};
  for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && c.indexOf(t) < 0 && (s[t] = e[t]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") {
    var a = 0;
    for (t = Object.getOwnPropertySymbols(e); a < t.length; a++) c.indexOf(t[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, t[a]) && (s[t[a]] = e[t[a]]);
  }
  return s;
};
const z = n.forwardRef((e, c) => {
  var s, t;
  const { prefixCls: a, openClassName: R, getTooltipContainer: F, color: L, overlayInnerStyle: W, children: u, afterOpenChange: V, afterVisibleChange: $, destroyTooltipOnHide: C, arrow: l = !0, title: p, overlay: O, builtinPlacements: D, arrowPointAtCenter: N = !1, autoAdjustOverflow: M = !0, motion: xe, getPopupContainer: U, placement: X = "top", mouseEnterDelay: k = 0.1, mouseLeaveDelay: B = 0.1, overlayStyle: Y, rootClassName: Z, overlayClassName: q, styles: f, classNames: d } = e, S = Te(e, ["prefixCls", "openClassName", "getTooltipContainer", "color", "overlayInnerStyle", "children", "afterOpenChange", "afterVisibleChange", "destroyTooltipOnHide", "arrow", "title", "overlay", "builtinPlacements", "arrowPointAtCenter", "autoAdjustOverflow", "motion", "getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName", "overlayClassName", "styles", "classNames"]), T = !!l, [, y] = he(), { getPopupContainer: G, getPrefixCls: x, direction: J, className: K, style: Q, classNames: I, styles: _ } = Se("tooltip"), v = Ee("Tooltip"), b = n.useRef(null), H = () => {
    var o;
    (o = b.current) === null || o === void 0 || o.forceAlign();
  };
  n.useImperativeHandle(c, () => {
    var o, r;
    return { forceAlign: H, forcePopupAlign: () => {
      v.deprecated(!1, "forcePopupAlign", "forceAlign"), H();
    }, nativeElement: (o = b.current) === null || o === void 0 ? void 0 : o.nativeElement, popupElement: (r = b.current) === null || r === void 0 ? void 0 : r.popupElement };
  }), process.env.NODE_ENV !== "production" && ([["visible", "open"], ["defaultVisible", "defaultOpen"], ["onVisibleChange", "onOpenChange"], ["afterVisibleChange", "afterOpenChange"], ["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"], ["overlayStyle", "styles={{ root: {} }}"], ["overlayInnerStyle", "styles={{ body: {} }}"], ["overlayClassName", 'classNames={{ root: "" }}']].forEach((o) => {
    let [r, i] = o;
    v.deprecated(!(r in e), r, i);
  }), process.env.NODE_ENV !== "production" && v(!C || typeof C == "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly."), process.env.NODE_ENV !== "production" && v(!l || typeof l == "boolean" || !("arrowPointAtCenter" in l), "deprecated", "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead."));
  const [ee, oe] = be(!1, { value: (s = e.open) !== null && s !== void 0 ? s : e.visible, defaultValue: (t = e.defaultOpen) !== null && t !== void 0 ? t : e.defaultVisible }), w = !p && !O && p !== 0, te = n.useMemo(() => {
    var o, r;
    let i = N;
    return typeof l == "object" && (i = (r = (o = l.pointAtCenter) !== null && o !== void 0 ? o : l.arrowPointAtCenter) !== null && r !== void 0 ? r : N), D || Ne({ arrowPointAtCenter: i, autoAdjustOverflow: M, arrowWidth: T ? y.sizePopupArrow : 0, borderRadius: y.borderRadius, offset: y.marginXXS, visibleFirst: !0 });
  }, [N, l, D, y]), P = n.useMemo(() => p === 0 ? p : O || p || "", [O, p]), re = n.createElement(ge, { space: !0 }, typeof P == "function" ? P() : P), m = x("tooltip", a), ne = x(), ae = e["data-popover-inject"];
  let E = ee;
  "open" in e || "visible" in e || !w || (E = !1);
  const A = n.isValidElement(u) && !we(u) ? u : n.createElement("span", null, u), g = A.props, le = g.className && typeof g.className != "string" ? g.className : j(g.className, R || `${m}-open`), [ie, se, pe] = Ve(m, !ae), h = De(m, L), me = h.arrowStyle, ce = j(q, { [`${m}-rtl`]: J === "rtl" }, h.className, Z, se, pe, K, I.root, d == null ? void 0 : d.root), ue = j(I.body, d == null ? void 0 : d.body), [fe, de] = Ce("Tooltip", S.zIndex), ye = n.createElement(ve, Object.assign({}, S, { zIndex: fe, showArrow: T, placement: X, mouseEnterDelay: k, mouseLeaveDelay: B, prefixCls: m, classNames: { root: ce, body: ue }, styles: { root: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, me), _.root), Q), Y), f == null ? void 0 : f.root), body: Object.assign(Object.assign(Object.assign(Object.assign({}, _.body), W), f == null ? void 0 : f.body), h.overlayStyle) }, getTooltipContainer: U || F || G, ref: b, builtinPlacements: te, overlay: re, visible: E, onVisibleChange: (o) => {
    var r, i;
    oe(!w && o), w || ((r = e.onOpenChange) === null || r === void 0 || r.call(e, o), (i = e.onVisibleChange) === null || i === void 0 || i.call(e, o));
  }, afterVisibleChange: V ?? $, arrowContent: n.createElement("span", { className: `${m}-arrow-content` }), motion: { motionName: Oe(ne, "zoom-big-fast", e.transitionName), motionDeadline: 1e3 }, destroyTooltipOnHide: !!C }), E ? Pe(A, { className: le }) : A);
  return ie(n.createElement(Ae.Provider, { value: de }, ye));
});
process.env.NODE_ENV !== "production" && (z.displayName = "Tooltip"), z._InternalPanelDoNotUseOrYouWillBeFired = je;
export {
  z as default
};
