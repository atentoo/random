import "../../../../@ant-design/cssinjs/es/extractStyle.js";
import "../../../../@ant-design/cssinjs/es/hooks/useCacheToken.js";
import "react";
import "../../../../@ant-design/cssinjs/es/StyleContext.js";
import { unit as $ } from "../../../../@ant-design/cssinjs/es/util/index.js";
import "../../../../@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js";
import "../../../../@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js";
import "../../../../@ant-design/cssinjs/es/hooks/useHMR.js";
import "../../../../rc-util/es/warning.js";
import "../../../../@ant-design/cssinjs/es/theme/createTheme.js";
import "../../../../@ant-design/cssinjs/es/theme/ThemeCache.js";
import "../../../../@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js";
import "../../../../rc-util/es/hooks/useLayoutEffect.js";
import "../../../../rc-util/es/ref.js";
import { merge as d } from "../../../../@ant-design/cssinjs-utils/es/util/statistic.js";
import "../../../../@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js";
import { genStyleHooks as m } from "../../theme/util/genStyleUtils.js";
const c = (i) => {
  const { componentCls: o } = i;
  return { [o]: { position: "relative", maxWidth: "100%", minHeight: 1 } };
}, p = (i, o) => ((l, t) => {
  const { prefixCls: a, componentCls: n, gridColumns: s } = l, r = {};
  for (let e = s; e >= 0; e--) e === 0 ? (r[`${n}${t}-${e}`] = { display: "none" }, r[`${n}-push-${e}`] = { insetInlineStart: "auto" }, r[`${n}-pull-${e}`] = { insetInlineEnd: "auto" }, r[`${n}${t}-push-${e}`] = { insetInlineStart: "auto" }, r[`${n}${t}-pull-${e}`] = { insetInlineEnd: "auto" }, r[`${n}${t}-offset-${e}`] = { marginInlineStart: 0 }, r[`${n}${t}-order-${e}`] = { order: 0 }) : (r[`${n}${t}-${e}`] = [{ "--ant-display": "block", display: "block" }, { display: "var(--ant-display)", flex: `0 0 ${e / s * 100}%`, maxWidth: e / s * 100 + "%" }], r[`${n}${t}-push-${e}`] = { insetInlineStart: e / s * 100 + "%" }, r[`${n}${t}-pull-${e}`] = { insetInlineEnd: e / s * 100 + "%" }, r[`${n}${t}-offset-${e}`] = { marginInlineStart: e / s * 100 + "%" }, r[`${n}${t}-order-${e}`] = { order: e });
  return r[`${n}${t}-flex`] = { flex: `var(--${a}${t}-flex)` }, r;
})(i, o), f = () => ({}), u = () => ({}), L = m("Grid", (i) => {
  const { componentCls: o } = i;
  return { [o]: { display: "flex", flexFlow: "row wrap", minWidth: 0, "&::before, &::after": { display: "flex" }, "&-no-wrap": { flexWrap: "nowrap" }, "&-start": { justifyContent: "flex-start" }, "&-center": { justifyContent: "center" }, "&-end": { justifyContent: "flex-end" }, "&-space-between": { justifyContent: "space-between" }, "&-space-around": { justifyContent: "space-around" }, "&-space-evenly": { justifyContent: "space-evenly" }, "&-top": { alignItems: "flex-start" }, "&-middle": { alignItems: "center" }, "&-bottom": { alignItems: "flex-end" } } };
}, f), x = (i) => ({ xs: i.screenXSMin, sm: i.screenSMMin, md: i.screenMDMin, lg: i.screenLGMin, xl: i.screenXLMin, xxl: i.screenXXLMin }), H = m("Grid", (i) => {
  const o = d(i, { gridColumns: 24 }), l = x(o);
  return delete l.xs, [c(o), p(o, ""), p(o, "-xs"), Object.keys(l).map((t) => ((a, n, s) => ({ [`@media (min-width: ${$(n)})`]: Object.assign({}, p(a, s)) }))(o, l[t], `-${t}`)).reduce((t, a) => Object.assign(Object.assign({}, t), a), {})];
}, u);
export {
  x as getMediaSize,
  u as prepareColComponentToken,
  f as prepareRowComponentToken,
  H as useColStyle,
  L as useRowStyle
};
