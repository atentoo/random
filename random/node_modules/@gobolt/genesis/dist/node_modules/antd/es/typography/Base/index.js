import * as t from "react";
import ze from "../../../../@ant-design/icons/es/icons/EditOutlined.js";
import Te from "../../../../../_virtual/index.js";
import De from "../../../../rc-resize-observer/es/index.js";
import We from "../../../../rc-util/es/Children/toArray.js";
import M from "../../../../rc-util/es/hooks/useLayoutEffect.js";
import Z from "../../../../rc-util/es/hooks/useMergedState.js";
import _e from "../../../../rc-util/es/omit.js";
import { composeRef as Fe } from "../../../../rc-util/es/ref.js";
import { isStyleSupport as ee } from "../../../../rc-util/es/Dom/styleChecker.js";
import "../../config-provider/index.js";
import Je from "../../locale/useLocale.js";
import Ve from "../../tooltip/index.js";
import qe from "../Editable.js";
import Ae from "../hooks/useCopyClick.js";
import z from "../hooks/useMergedConfig.js";
import Be from "../hooks/usePrevious.js";
import Ge from "../hooks/useTooltipProps.js";
import He from "../Typography.js";
import Ke from "./CopyBtn.js";
import Qe from "./Ellipsis.js";
import Ue from "./EllipsisTooltip.js";
import { isEleEllipsis as Xe, isValidText as Ye } from "./util.js";
import { ConfigContext as Ze } from "../../config-provider/context.js";
var et = function(a, k) {
  var y = {};
  for (var i in a) Object.prototype.hasOwnProperty.call(a, i) && k.indexOf(i) < 0 && (y[i] = a[i]);
  if (a != null && typeof Object.getOwnPropertySymbols == "function") {
    var d = 0;
    for (i = Object.getOwnPropertySymbols(a); d < i.length; d++) k.indexOf(i[d]) < 0 && Object.prototype.propertyIsEnumerable.call(a, i[d]) && (y[i[d]] = a[i[d]]);
  }
  return y;
};
const ht = t.forwardRef((a, k) => {
  var y;
  const { prefixCls: i, className: d, style: T, type: D, disabled: te, children: f, ellipsis: oe, editable: ne, copyable: le, component: W, title: $ } = a, ie = et(a, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]), { getPrefixCls: re, direction: _ } = t.useContext(Ze), [s] = Je("Text"), j = t.useRef(null), F = t.useRef(null), m = re("typography", i), ae = _e(ie, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]), [O, n] = z(ne), [h, se] = Z(!1, { value: n.editing }), { triggerType: J = ["icon"] } = n, I = (e) => {
    var o;
    e && ((o = n.onStart) === null || o === void 0 || o.call(n)), se(e);
  }, pe = Be(h);
  M(() => {
    var e;
    !h && pe && ((e = F.current) === null || e === void 0 || e.focus());
  }, [h]);
  const V = (e) => {
    e == null || e.preventDefault(), I(!0);
  }, ce = (e) => {
    var o;
    (o = n.onChange) === null || o === void 0 || o.call(n, e), I(!1);
  }, de = () => {
    var e;
    (e = n.onCancel) === null || e === void 0 || e.call(n), I(!1);
  }, [S, q] = z(le), { copied: A, copyLoading: B, onClick: me } = Ae({ copyConfig: q, children: f }), [G, ue] = t.useState(!1), [H, fe] = t.useState(!1), [K, be] = t.useState(!1), [Q, ye] = t.useState(!1), [xe, ve] = t.useState(!0), [b, l] = z(oe, { expandable: !1, symbol: (e) => e ? s == null ? void 0 : s.collapse : s == null ? void 0 : s.expand }), [u, Ee] = Z(l.defaultExpanded || !1, { value: l.expanded }), r = b && (!u || l.expandable === "collapsible"), { rows: g = 1 } = l, w = t.useMemo(() => r && (l.suffix !== void 0 || l.onEllipsis || l.expandable || O || S), [r, l, O, S]);
  M(() => {
    b && !w && (ue(ee("webkitLineClamp")), fe(ee("textOverflow")));
  }, [w, b]);
  const [p, ge] = t.useState(r), U = t.useMemo(() => !w && (g === 1 ? H : G), [w, H, G]);
  M(() => {
    ge(U && r);
  }, [U, r]);
  const X = r && (p ? Q : K), Ce = r && g === 1 && p, P = r && g > 1 && p, [Y, ke] = t.useState(0), Oe = (e) => {
    var o;
    be(e), K !== e && ((o = l.onEllipsis) === null || o === void 0 || o.call(l, e));
  };
  t.useEffect(() => {
    const e = j.current;
    if (b && p && e) {
      const o = Xe(e);
      Q !== o && ye(o);
    }
  }, [b, p, f, P, xe, Y]), t.useEffect(() => {
    const e = j.current;
    if (typeof IntersectionObserver > "u" || !e || !p || !r) return;
    const o = new IntersectionObserver(() => {
      ve(!!e.offsetParent);
    });
    return o.observe(e), () => {
      o.disconnect();
    };
  }, [p, r]);
  const N = Ge(l.tooltip, n.text, f), L = t.useMemo(() => {
    if (b && !p) return [n.text, f, $, N.title].find(Ye);
  }, [b, p, $, N.title, X]);
  if (h) return t.createElement(qe, { value: (y = n.text) !== null && y !== void 0 ? y : typeof f == "string" ? f : "", onSave: ce, onCancel: de, onEnd: n.onEnd, prefixCls: m, className: d, style: T, direction: _, component: W, maxLength: n.maxLength, autoSize: n.autoSize, enterIcon: n.enterIcon });
  const he = () => {
    const { expandable: e, symbol: o } = l;
    return e ? t.createElement("button", { type: "button", key: "expand", className: `${m}-${u ? "collapse" : "expand"}`, onClick: (v) => ((c, E) => {
      var C;
      Ee(E.expanded), (C = l.onExpand) === null || C === void 0 || C.call(l, c, E);
    })(v, { expanded: !u }), "aria-label": u ? s.collapse : s == null ? void 0 : s.expand }, typeof o == "function" ? o(u) : o) : null;
  }, Se = () => {
    if (!O) return;
    const { icon: e, tooltip: o, tabIndex: v } = n, c = We(o)[0] || (s == null ? void 0 : s.edit), E = typeof c == "string" ? c : "";
    return J.includes("icon") ? t.createElement(Ve, { key: "edit", title: o === !1 ? "" : c }, t.createElement("button", { type: "button", ref: F, className: `${m}-edit`, onClick: V, "aria-label": E, tabIndex: v }, e || t.createElement(ze, { role: "button" }))) : null;
  }, we = (e) => [e && he(), Se(), S ? t.createElement(Ke, Object.assign({ key: "copy" }, q, { prefixCls: m, copied: A, locale: s, onCopy: me, loading: B, iconOnly: f == null })) : null];
  return t.createElement(De, { onResize: (e) => {
    let { offsetWidth: o } = e;
    ke(o);
  }, disabled: !r }, (e) => t.createElement(Ue, { tooltipProps: N, enableEllipsis: r, isEllipsis: X }, t.createElement(He, Object.assign({ className: Te({ [`${m}-${D}`]: D, [`${m}-disabled`]: te, [`${m}-ellipsis`]: b, [`${m}-ellipsis-single-line`]: Ce, [`${m}-ellipsis-multiple-line`]: P }, d), prefixCls: i, style: Object.assign(Object.assign({}, T), { WebkitLineClamp: P ? g : void 0 }), component: W, ref: Fe(e, j, k), direction: _, onClick: J.includes("text") ? V : void 0, "aria-label": L == null ? void 0 : L.toString(), title: $ }, ae), t.createElement(Qe, { enableMeasure: r && !p, text: f, rows: g, width: Y, onEllipsis: Oe, expanded: u, miscDeps: [A, u, B, O, S, s] }, (o, v) => function(c, E) {
    let { mark: C, code: $e, underline: je, delete: Ie, strong: Pe, keyboard: Ne, italic: Le } = c, R = E;
    function x(Re, Me) {
      Me && (R = t.createElement(Re, {}, R));
    }
    return x("strong", Pe), x("u", je), x("del", Ie), x("code", $e), x("mark", C), x("kbd", Ne), x("i", Le), R;
  }(a, t.createElement(t.Fragment, null, o.length > 0 && v && !u && L ? t.createElement("span", { key: "show-content", "aria-hidden": !0 }, o) : o, ((c) => [c && !u && t.createElement("span", { "aria-hidden": !0, key: "ellipsis" }, "..."), l.suffix, we(c)])(v)))))));
});
export {
  ht as default
};
