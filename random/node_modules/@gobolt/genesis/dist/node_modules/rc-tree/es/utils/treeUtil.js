import D from "../../../@babel/runtime/helpers/esm/typeof.js";
import x from "../../../@babel/runtime/helpers/esm/toConsumableArray.js";
import T from "../../../@babel/runtime/helpers/esm/objectSpread2.js";
import b from "../../../@babel/runtime/helpers/esm/objectWithoutProperties.js";
import w from "../../../rc-util/es/Children/toArray.js";
import C from "../../../rc-util/es/omit.js";
import { warningOnce as O } from "../../../rc-util/es/warning.js";
import j from "./keyUtil.js";
var B = ["children"];
function P(e, n) {
  return "".concat(e, "-").concat(n);
}
function _(e) {
  return e && e.type && e.type.isTreeNode;
}
function K(e, n) {
  return e ?? n;
}
function E(e) {
  var n = e || {}, i = n.title || "title";
  return { title: i, _title: n._title || [i], key: n.key || "key", children: n.children || "children" };
}
function L(e, n) {
  var i = /* @__PURE__ */ new Map();
  (function o(c) {
    var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    (c || []).forEach(function(d) {
      var l = d[n.key], s = d[n.children];
      O(l != null, "Tree node must have a certain key: [".concat(u).concat(l, "]"));
      var a = String(l);
      O(!i.has(a) || l == null, "Same 'key' exist in the Tree: ".concat(a)), i.set(a, !0), o(s, "".concat(u).concat(a, " > "));
    });
  })(e);
}
function Q(e) {
  return function n(i) {
    return w(i).map(function(o) {
      if (!_(o)) return O(!o, "Tree/TreeNode can only accept TreeNode as children."), null;
      var c = o.key, u = o.props, d = u.children, l = b(u, B), s = T({ key: c }, l), a = n(d);
      return a.length && (s.children = a), s;
    }).filter(function(o) {
      return o;
    });
  }(e);
}
function R(e, n, i) {
  var o = E(i), c = o._title, u = o.key, d = o.children, l = new Set(n === !0 ? [] : n), s = [];
  return function a(v) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return v.map(function(r, g) {
      for (var f, m = P(t ? t.pos : "0", g), y = K(r[u], m), h = 0; h < c.length; h += 1) {
        var k = c[h];
        if (r[k] !== void 0) {
          f = r[k];
          break;
        }
      }
      var p = Object.assign(C(r, [].concat(x(c), [u, d])), { title: f, key: y, parent: t, pos: m, children: null, data: r, isStart: [].concat(x(t ? t.isStart : []), [g === 0]), isEnd: [].concat(x(t ? t.isEnd : []), [g === v.length - 1]) });
      return s.push(p), n === !0 || l.has(y) ? p.children = a(r[d] || [], p) : p.children = [], p;
    });
  }(e), s;
}
function F(e, n, i) {
  var o, c = (D(i) === "object" ? i : { externalGetKey: i }) || {}, u = c.childrenPropName, d = c.externalGetKey, l = E(c.fieldNames), s = l.key, a = l.children, v = u || a;
  d ? typeof d == "string" ? o = function(t) {
    return t[d];
  } : typeof d == "function" && (o = function(t) {
    return d(t);
  }) : o = function(t, r) {
    return K(t[s], r);
  }, function t(r, g, f, m) {
    var y = r ? r[v] : e, h = r ? P(f.pos, g) : "0", k = r ? [].concat(x(m), [r]) : [];
    if (r) {
      var p = o(r, h), N = { node: r, index: g, pos: h, key: p, parentPos: f.node ? f.pos : null, level: f.level + 1, nodes: k };
      n(N);
    }
    y && y.forEach(function(G, S) {
      t(G, S, { node: r, pos: h, level: f ? f.level + 1 : -1 }, k);
    });
  }(null);
}
function U(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = n.initWrapper, o = n.processEntity, c = n.onProcessFinished, u = n.externalGetKey, d = n.childrenPropName, l = n.fieldNames, s = u || (arguments.length > 2 ? arguments[2] : void 0), a = {}, v = {}, t = { posEntities: a, keyEntities: v };
  return i && (t = i(t) || t), F(e, function(r) {
    var g = r.node, f = r.index, m = r.pos, y = r.key, h = r.parentPos, k = r.level, p = { node: g, nodes: r.nodes, index: f, key: y, pos: m, level: k }, N = K(y, m);
    a[m] = p, v[N] = p, p.parent = a[h], p.parent && (p.parent.children = p.parent.children || [], p.parent.children.push(p)), o && o(p, t);
  }, { externalGetKey: s, childrenPropName: d, fieldNames: l }), c && c(t), t;
}
function V(e, n) {
  var i = n.expandedKeys, o = n.selectedKeys, c = n.loadedKeys, u = n.loadingKeys, d = n.checkedKeys, l = n.halfCheckedKeys, s = n.dragOverNodeKey, a = n.dropPosition, v = n.keyEntities, t = j(v, e);
  return { eventKey: e, expanded: i.indexOf(e) !== -1, selected: o.indexOf(e) !== -1, loaded: c.indexOf(e) !== -1, loading: u.indexOf(e) !== -1, checked: d.indexOf(e) !== -1, halfChecked: l.indexOf(e) !== -1, pos: String(t ? t.pos : ""), dragOver: s === e && a === 0, dragOverGapTop: s === e && a === -1, dragOverGapBottom: s === e && a === 1 };
}
function X(e) {
  var n = e.data, i = e.expanded, o = e.selected, c = e.checked, u = e.loaded, d = e.loading, l = e.halfChecked, s = e.dragOver, a = e.dragOverGapTop, v = e.dragOverGapBottom, t = e.pos, r = e.active, g = e.eventKey, f = T(T({}, n), {}, { expanded: i, selected: o, checked: c, loaded: u, loading: d, halfChecked: l, dragOver: s, dragOverGapTop: a, dragOverGapBottom: v, pos: t, active: r, key: g });
  return "props" in f || Object.defineProperty(f, "props", { get: function() {
    return O(!1, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`."), e;
  } }), f;
}
export {
  U as convertDataToEntities,
  X as convertNodePropsToEventData,
  Q as convertTreeToData,
  E as fillFieldNames,
  R as flattenTreeData,
  K as getKey,
  P as getPosition,
  V as getTreeNodeProps,
  _ as isTreeNode,
  F as traverseDataNodes,
  L as warningWithoutKey
};
