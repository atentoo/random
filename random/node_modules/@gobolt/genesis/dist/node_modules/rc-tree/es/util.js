import S from "../../@babel/runtime/helpers/esm/toConsumableArray.js";
import B from "../../@babel/runtime/helpers/esm/typeof.js";
import { warningOnce as F } from "../../rc-util/es/warning.js";
import "react";
import "./TreeNode.js";
import f from "./utils/keyUtil.js";
function H(r, e) {
  if (!r) return [];
  var n = r.slice(), d = n.indexOf(e);
  return d >= 0 && n.splice(d, 1), n;
}
function J(r, e) {
  var n = (r || []).slice();
  return n.indexOf(e) === -1 && n.push(e), n;
}
function O(r) {
  return r.split("-");
}
function M(r, e) {
  var n = [];
  return function d() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach(function(t) {
      var i = t.key, l = t.children;
      n.push(i), d(l);
    });
  }(f(e, r).children), n;
}
function I(r) {
  if (r.parent) {
    var e = O(r.pos);
    return Number(e[e.length - 1]) === r.parent.children.length - 1;
  }
  return !1;
}
function R(r) {
  var e = O(r.pos);
  return Number(e[e.length - 1]) === 0;
}
function Q(r, e, n, d, t, i, l, h, D, E) {
  var v, T = r.clientX, k = r.clientY, m = r.target.getBoundingClientRect(), N = m.top, K = m.height, P = ((E === "rtl" ? -1 : 1) * (((t == null ? void 0 : t.x) || 0) - T) - 12) / d, C = D.filter(function(y) {
    var p;
    return (p = h[y]) === null || p === void 0 || (p = p.children) === null || p === void 0 ? void 0 : p.length;
  }), o = f(h, n.eventKey);
  if (k < N + K / 2) {
    var b = l.findIndex(function(y) {
      return y.key === o.key;
    }), j = l[b <= 0 ? 0 : b - 1].key;
    o = f(h, j);
  }
  var w = o.key, L = o, A = o.key, a = 0, g = 0;
  if (!C.includes(w)) for (var x = 0; x < P && I(o); x += 1) o = o.parent, g += 1;
  var c = e.data, u = o.node, s = !0;
  return R(o) && o.level === 0 && k < N + K / 2 && i({ dragNode: c, dropNode: u, dropPosition: -1 }) && o.key === n.eventKey ? a = -1 : (L.children || []).length && C.includes(A) ? i({ dragNode: c, dropNode: u, dropPosition: 0 }) ? a = 0 : s = !1 : g === 0 ? P > -1.5 ? i({ dragNode: c, dropNode: u, dropPosition: 1 }) ? a = 1 : s = !1 : i({ dragNode: c, dropNode: u, dropPosition: 0 }) ? a = 0 : i({ dragNode: c, dropNode: u, dropPosition: 1 }) ? a = 1 : s = !1 : i({ dragNode: c, dropNode: u, dropPosition: 1 }) ? a = 1 : s = !1, { dropPosition: a, dropLevelOffset: g, dropTargetKey: o.key, dropTargetPos: o.pos, dragOverNodeKey: A, dropContainerKey: a === 0 ? null : ((v = o.parent) === null || v === void 0 ? void 0 : v.key) || null, dropAllowed: s };
}
function V(r, e) {
  if (r) return e.multiple ? r.slice() : r.length ? [r[0]] : r;
}
function W(r) {
  if (!r) return null;
  var e;
  if (Array.isArray(r)) e = { checkedKeys: r, halfCheckedKeys: void 0 };
  else {
    if (B(r) !== "object") return F(!1, "`checkedKeys` is not an array or an object"), null;
    e = { checkedKeys: r.checked || void 0, halfCheckedKeys: r.halfChecked || void 0 };
  }
  return e;
}
function Z(r, e) {
  var n = /* @__PURE__ */ new Set();
  function d(t) {
    if (!n.has(t)) {
      var i = f(e, t);
      if (i) {
        n.add(t);
        var l = i.parent;
        i.node.disabled || l && d(l.key);
      }
    }
  }
  return (r || []).forEach(function(t) {
    d(t);
  }), S(n);
}
export {
  J as arrAdd,
  H as arrDel,
  Q as calcDropPosition,
  V as calcSelectedKeys,
  Z as conductExpandParent,
  M as getDragChildrenKeys,
  R as isFirstChild,
  I as isLastChild,
  W as parseCheckedKeys,
  O as posToArr
};
