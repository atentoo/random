import G from "../../@babel/runtime/helpers/esm/extends.js";
import B from "../../@babel/runtime/helpers/esm/objectWithoutProperties.js";
import K from "../../@babel/runtime/helpers/esm/regeneratorRuntime.js";
import J from "../../@babel/runtime/helpers/esm/asyncToGenerator.js";
import T from "../../@babel/runtime/helpers/esm/objectSpread2.js";
import U from "../../@babel/runtime/helpers/esm/toConsumableArray.js";
import Q from "../../@babel/runtime/helpers/esm/classCallCheck.js";
import X from "../../@babel/runtime/helpers/esm/createClass.js";
import o from "../../@babel/runtime/helpers/esm/assertThisInitialized.js";
import Y from "../../@babel/runtime/helpers/esm/inherits.js";
import Z from "../../@babel/runtime/helpers/esm/createSuper.js";
import i from "../../@babel/runtime/helpers/esm/defineProperty.js";
import $ from "../../rc-util/es/Children/toArray.js";
import S from "../../rc-util/es/isEqual.js";
import { warningOnce as H } from "../../rc-util/es/warning.js";
import * as R from "react";
import z, { HOOK_MARK as I } from "./FieldContext.js";
import ee from "./ListContext.js";
import { toArray as q } from "./utils/typeUtil.js";
import { validateRules as te } from "./utils/validateUtil.js";
import { getNamePath as j, containsNamePath as _, defaultGetValueFromEvent as re } from "./utils/valueUtil.js";
import ne from "../../rc-util/es/utils/get.js";
var ie = ["name"], g = [];
function D(N, b, f, u, e, r) {
  return typeof N == "function" ? N(b, f, "source" in r ? { source: r.source } : {}) : u !== e;
}
var A = function(N) {
  Y(f, N);
  var b = Z(f);
  function f(u) {
    var e;
    return Q(this, f), e = b.call(this, u), i(o(e), "state", { resetCount: 0 }), i(o(e), "cancelRegisterFunc", null), i(o(e), "mounted", !1), i(o(e), "touched", !1), i(o(e), "dirty", !1), i(o(e), "validatePromise", void 0), i(o(e), "prevValidating", void 0), i(o(e), "errors", g), i(o(e), "warnings", g), i(o(e), "cancelRegister", function() {
      var r = e.props, n = r.preserve, t = r.isListField, l = r.name;
      e.cancelRegisterFunc && e.cancelRegisterFunc(t, n, j(l)), e.cancelRegisterFunc = null;
    }), i(o(e), "getNamePath", function() {
      var r = e.props, n = r.name, t = r.fieldContext.prefixName;
      return n !== void 0 ? [].concat(U(t === void 0 ? [] : t), U(n)) : [];
    }), i(o(e), "getRules", function() {
      var r = e.props, n = r.rules, t = n === void 0 ? [] : n, l = r.fieldContext;
      return t.map(function(a) {
        return typeof a == "function" ? a(l) : a;
      });
    }), i(o(e), "refresh", function() {
      e.mounted && e.setState(function(r) {
        return { resetCount: r.resetCount + 1 };
      });
    }), i(o(e), "metaCache", null), i(o(e), "triggerMetaEvent", function(r) {
      var n = e.props.onMetaChange;
      if (n) {
        var t = T(T({}, e.getMeta()), {}, { destroy: r });
        S(e.metaCache, t) || n(t), e.metaCache = t;
      } else e.metaCache = null;
    }), i(o(e), "onStoreChange", function(r, n, t) {
      var l = e.props, a = l.shouldUpdate, E = l.dependencies, M = E === void 0 ? [] : E, h = l.onReset, V = t.store, c = e.getNamePath(), y = e.getValue(r), F = e.getValue(V), x = n && _(n, c);
      switch (t.type !== "valueUpdate" || t.source !== "external" || S(y, F) || (e.touched = !0, e.dirty = !0, e.validatePromise = null, e.errors = g, e.warnings = g, e.triggerMetaEvent()), t.type) {
        case "reset":
          if (!n || x) return e.touched = !1, e.dirty = !1, e.validatePromise = void 0, e.errors = g, e.warnings = g, e.triggerMetaEvent(), h == null || h(), void e.refresh();
          break;
        case "remove":
          if (a && D(a, r, V, y, F, t)) return void e.reRender();
          break;
        case "setField":
          var d = t.data;
          if (x) return "touched" in d && (e.touched = d.touched), "validating" in d && !("originRCField" in d) && (e.validatePromise = d.validating ? Promise.resolve([]) : null), "errors" in d && (e.errors = d.errors || g), "warnings" in d && (e.warnings = d.warnings || g), e.dirty = !0, e.triggerMetaEvent(), void e.reRender();
          if ("value" in d && _(n, c, !0) || a && !c.length && D(a, r, V, y, F, t)) return void e.reRender();
          break;
        case "dependenciesUpdate":
          if (M.map(j).some(function(C) {
            return _(t.relatedFields, C);
          })) return void e.reRender();
          break;
        default:
          if (x || (!M.length || c.length || a) && D(a, r, V, y, F, t)) return void e.reRender();
      }
      a === !0 && e.reRender();
    }), i(o(e), "validateRules", function(r) {
      var n = e.getNamePath(), t = e.getValue(), l = r || {}, a = l.triggerName, E = l.validateOnly, M = E !== void 0 && E, h = Promise.resolve().then(J(K().mark(function V() {
        var c, y, F, x, d, C, L;
        return K().wrap(function(m) {
          for (; ; ) switch (m.prev = m.next) {
            case 0:
              if (e.mounted) {
                m.next = 2;
                break;
              }
              return m.abrupt("return", []);
            case 2:
              if (c = e.props, y = c.validateFirst, F = y !== void 0 && y, x = c.messageVariables, d = c.validateDebounce, C = e.getRules(), a && (C = C.filter(function(p) {
                return p;
              }).filter(function(p) {
                var v = p.validateTrigger;
                return !v || q(v).includes(a);
              })), !d || !a) {
                m.next = 10;
                break;
              }
              return m.next = 8, new Promise(function(p) {
                setTimeout(p, d);
              });
            case 8:
              if (e.validatePromise === h) {
                m.next = 10;
                break;
              }
              return m.abrupt("return", []);
            case 10:
              return (L = te(n, t, C, r, F, x)).catch(function(p) {
                return p;
              }).then(function() {
                var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : g;
                if (e.validatePromise === h) {
                  var v;
                  e.validatePromise = null;
                  var k = [], s = [];
                  (v = p.forEach) === null || v === void 0 || v.call(p, function(w) {
                    var P = w.rule.warningOnly, O = w.errors, W = O === void 0 ? g : O;
                    P ? s.push.apply(s, U(W)) : k.push.apply(k, U(W));
                  }), e.errors = k, e.warnings = s, e.triggerMetaEvent(), e.reRender();
                }
              }), m.abrupt("return", L);
            case 13:
            case "end":
              return m.stop();
          }
        }, V);
      })));
      return M || (e.validatePromise = h, e.dirty = !0, e.errors = g, e.warnings = g, e.triggerMetaEvent(), e.reRender()), h;
    }), i(o(e), "isFieldValidating", function() {
      return !!e.validatePromise;
    }), i(o(e), "isFieldTouched", function() {
      return e.touched;
    }), i(o(e), "isFieldDirty", function() {
      return !(!e.dirty && e.props.initialValue === void 0) || (0, e.props.fieldContext.getInternalHooks(I).getInitialValue)(e.getNamePath()) !== void 0;
    }), i(o(e), "getErrors", function() {
      return e.errors;
    }), i(o(e), "getWarnings", function() {
      return e.warnings;
    }), i(o(e), "isListField", function() {
      return e.props.isListField;
    }), i(o(e), "isList", function() {
      return e.props.isList;
    }), i(o(e), "isPreserve", function() {
      return e.props.preserve;
    }), i(o(e), "getMeta", function() {
      return e.prevValidating = e.isFieldValidating(), { touched: e.isFieldTouched(), validating: e.prevValidating, errors: e.errors, warnings: e.warnings, name: e.getNamePath(), validated: e.validatePromise === null };
    }), i(o(e), "getOnlyChild", function(r) {
      if (typeof r == "function") {
        var n = e.getMeta();
        return T(T({}, e.getOnlyChild(r(e.getControlled(), n, e.props.fieldContext))), {}, { isFunction: !0 });
      }
      var t = $(r);
      return t.length === 1 && R.isValidElement(t[0]) ? { child: t[0], isFunction: !1 } : { child: t, isFunction: !1 };
    }), i(o(e), "getValue", function(r) {
      var n = e.props.fieldContext.getFieldsValue, t = e.getNamePath();
      return ne(r || n(!0), t);
    }), i(o(e), "getControlled", function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = e.props, t = n.name, l = n.trigger, a = n.validateTrigger, E = n.getValueFromEvent, M = n.normalize, h = n.valuePropName, V = n.getValueProps, c = n.fieldContext, y = a !== void 0 ? a : c.validateTrigger, F = e.getNamePath(), x = c.getInternalHooks, d = c.getFieldsValue, C = x(I).dispatch, L = e.getValue(), m = V || function(s) {
        return i({}, h, s);
      }, p = r[l], v = t !== void 0 ? m(L) : {};
      process.env.NODE_ENV !== "production" && v && Object.keys(v).forEach(function(s) {
        H(typeof v[s] != "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(s, ")"));
      });
      var k = T(T({}, r), v);
      return k[l] = function() {
        var s;
        e.touched = !0, e.dirty = !0, e.triggerMetaEvent();
        for (var w = arguments.length, P = new Array(w), O = 0; O < w; O++) P[O] = arguments[O];
        s = E ? E.apply(void 0, P) : re.apply(void 0, [h].concat(P)), M && (s = M(s, L, d(!0))), s !== L && C({ type: "updateValue", namePath: F, value: s }), p && p.apply(void 0, P);
      }, q(y || []).forEach(function(s) {
        var w = k[s];
        k[s] = function() {
          w && w.apply(void 0, arguments);
          var P = e.props.rules;
          P && P.length && C({ type: "validateField", namePath: F, triggerName: s });
        };
      }), k;
    }), u.fieldContext && (0, (0, u.fieldContext.getInternalHooks)(I).initEntityValue)(o(e)), e;
  }
  return X(f, [{ key: "componentDidMount", value: function() {
    var u = this.props, e = u.shouldUpdate, r = u.fieldContext;
    if (this.mounted = !0, r) {
      var n = (0, r.getInternalHooks)(I).registerField;
      this.cancelRegisterFunc = n(this);
    }
    e === !0 && this.reRender();
  } }, { key: "componentWillUnmount", value: function() {
    this.cancelRegister(), this.triggerMetaEvent(!0), this.mounted = !1;
  } }, { key: "reRender", value: function() {
    this.mounted && this.forceUpdate();
  } }, { key: "render", value: function() {
    var u, e = this.state.resetCount, r = this.props.children, n = this.getOnlyChild(r), t = n.child;
    return n.isFunction ? u = t : R.isValidElement(t) ? u = R.cloneElement(t, this.getControlled(t.props)) : (H(!t, "`children` of Field is not validate ReactElement."), u = t), R.createElement(R.Fragment, { key: e }, u);
  } }]), f;
}(R.Component);
function ke(N) {
  var b, f = N.name, u = B(N, ie), e = R.useContext(z), r = R.useContext(ee), n = f !== void 0 ? j(f) : void 0, t = (b = u.isListField) !== null && b !== void 0 ? b : !!r, l = "keep";
  return t || (l = "_".concat((n || []).join("_"))), process.env.NODE_ENV !== "production" && u.preserve === !1 && t && n.length <= 1 && H(!1, "`preserve` should not apply on Form.List fields."), R.createElement(A, G({ key: l, name: n, isListField: t }, u, { fieldContext: e }));
}
i(A, "contextType", z), i(A, "defaultProps", { trigger: "onChange", valuePropName: "value" });
export {
  ke as default
};
