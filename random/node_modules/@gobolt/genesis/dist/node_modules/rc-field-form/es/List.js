import N from "../../@babel/runtime/helpers/esm/objectSpread2.js";
import a from "../../@babel/runtime/helpers/esm/toConsumableArray.js";
import * as o from "react";
import { warningOnce as p } from "../../rc-util/es/warning.js";
import E from "./FieldContext.js";
import D from "./Field.js";
import { getNamePath as x, move as L } from "./utils/valueUtil.js";
import V from "./ListContext.js";
function B(s) {
  var g = s.name, F = s.initialValue, h = s.children, A = s.rules, C = s.validateTrigger, k = s.isListField, f = o.useContext(E), b = o.useContext(V), n = o.useRef({ keys: [], id: 0 }).current, u = o.useMemo(function() {
    var t = x(f.prefixName) || [];
    return [].concat(a(t), a(x(g)));
  }, [f.prefixName, g]), w = o.useMemo(function() {
    return N(N({}, f), {}, { prefixName: u });
  }, [f, u]), M = o.useMemo(function() {
    return { getKey: function(t) {
      var c = u.length, l = t[c];
      return [n.keys[l], t.slice(c + 1)];
    } };
  }, [u]);
  return typeof h != "function" ? (p(!1, "Form.List only accepts function as children."), null) : o.createElement(V.Provider, { value: M }, o.createElement(E.Provider, { value: w }, o.createElement(D, { name: [], shouldUpdate: function(t, c, l) {
    return l.source !== "internal" && t !== c;
  }, rules: A, validateTrigger: C, initialValue: F, isList: !0, isListField: k ?? !!b }, function(t, c) {
    var l = t.value, O = l === void 0 ? [] : l, m = t.onChange, P = f.getFieldValue, d = function() {
      return P(u || []) || [];
    }, T = { add: function(i, e) {
      var r = d();
      e >= 0 && e <= r.length ? (n.keys = [].concat(a(n.keys.slice(0, e)), [n.id], a(n.keys.slice(e))), m([].concat(a(r.slice(0, e)), [i], a(r.slice(e))))) : (process.env.NODE_ENV !== "production" && (e < 0 || e > r.length) && p(!1, "The second parameter of the add function should be a valid positive number."), n.keys = [].concat(a(n.keys), [n.id]), m([].concat(a(r), [i]))), n.id += 1;
    }, remove: function(i) {
      var e = d(), r = new Set(Array.isArray(i) ? i : [i]);
      r.size <= 0 || (n.keys = n.keys.filter(function(j, y) {
        return !r.has(y);
      }), m(e.filter(function(j, y) {
        return !r.has(y);
      })));
    }, move: function(i, e) {
      if (i !== e) {
        var r = d();
        i < 0 || i >= r.length || e < 0 || e >= r.length || (n.keys = L(n.keys, i, e), m(L(r, i, e)));
      }
    } }, v = O || [];
    return Array.isArray(v) || (v = [], process.env.NODE_ENV !== "production" && p(!1, "Current value of '".concat(u.join(" > "), "' is not an array type."))), h(v.map(function(i, e) {
      var r = n.keys[e];
      return r === void 0 && (n.keys[e] = n.id, r = n.keys[e], n.id += 1), { name: e, key: r, isListField: !0 };
    }), T, c);
  })));
}
export {
  B as default
};
