import R from "./typeof.js";
function H() {
  H = function() {
    return h;
  };
  var f, h = {}, S = Object.prototype, p = S.hasOwnProperty, w = Object.defineProperty || function(e, t, r) {
    e[t] = r.value;
  }, O = typeof Symbol == "function" ? Symbol : {}, x = O.iterator || "@@iterator", W = O.asyncIterator || "@@asyncIterator", j = O.toStringTag || "@@toStringTag";
  function l(e, t, r) {
    return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t];
  }
  try {
    l({}, "");
  } catch {
    l = function(t, r, o) {
      return t[r] = o;
    };
  }
  function A(e, t, r, o) {
    var n = t && t.prototype instanceof G ? t : G, a = Object.create(n.prototype), i = new T(o || []);
    return w(a, "_invoke", { value: z(e, r, i) }), a;
  }
  function k(e, t, r) {
    try {
      return { type: "normal", arg: e.call(t, r) };
    } catch (o) {
      return { type: "throw", arg: o };
    }
  }
  h.wrap = A;
  var M = "suspendedStart", q = "suspendedYield", C = "executing", L = "completed", s = {};
  function G() {
  }
  function b() {
  }
  function y() {
  }
  var I = {};
  l(I, x, function() {
    return this;
  });
  var N = Object.getPrototypeOf, E = N && N(N(F([])));
  E && E !== S && p.call(E, x) && (I = E);
  var d = y.prototype = G.prototype = Object.create(I);
  function Y(e) {
    ["next", "throw", "return"].forEach(function(t) {
      l(e, t, function(r) {
        return this._invoke(t, r);
      });
    });
  }
  function _(e, t) {
    function r(n, a, i, c) {
      var u = k(e[n], e, a);
      if (u.type !== "throw") {
        var g = u.arg, m = g.value;
        return m && R(m) == "object" && p.call(m, "__await") ? t.resolve(m.__await).then(function(v) {
          r("next", v, i, c);
        }, function(v) {
          r("throw", v, i, c);
        }) : t.resolve(m).then(function(v) {
          g.value = v, i(g);
        }, function(v) {
          return r("throw", v, i, c);
        });
      }
      c(u.arg);
    }
    var o;
    w(this, "_invoke", { value: function(n, a) {
      function i() {
        return new t(function(c, u) {
          r(n, a, c, u);
        });
      }
      return o = o ? o.then(i, i) : i();
    } });
  }
  function z(e, t, r) {
    var o = M;
    return function(n, a) {
      if (o === C) throw Error("Generator is already running");
      if (o === L) {
        if (n === "throw") throw a;
        return { value: f, done: !0 };
      }
      for (r.method = n, r.arg = a; ; ) {
        var i = r.delegate;
        if (i) {
          var c = D(i, r);
          if (c) {
            if (c === s) continue;
            return c;
          }
        }
        if (r.method === "next") r.sent = r._sent = r.arg;
        else if (r.method === "throw") {
          if (o === M) throw o = L, r.arg;
          r.dispatchException(r.arg);
        } else r.method === "return" && r.abrupt("return", r.arg);
        o = C;
        var u = k(e, t, r);
        if (u.type === "normal") {
          if (o = r.done ? L : q, u.arg === s) continue;
          return { value: u.arg, done: r.done };
        }
        u.type === "throw" && (o = L, r.method = "throw", r.arg = u.arg);
      }
    };
  }
  function D(e, t) {
    var r = t.method, o = e.iterator[r];
    if (o === f) return t.delegate = null, r === "throw" && e.iterator.return && (t.method = "return", t.arg = f, D(e, t), t.method === "throw") || r !== "return" && (t.method = "throw", t.arg = new TypeError("The iterator does not provide a '" + r + "' method")), s;
    var n = k(o, e.iterator, t.arg);
    if (n.type === "throw") return t.method = "throw", t.arg = n.arg, t.delegate = null, s;
    var a = n.arg;
    return a ? a.done ? (t[e.resultName] = a.value, t.next = e.nextLoc, t.method !== "return" && (t.method = "next", t.arg = f), t.delegate = null, s) : a : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, s);
  }
  function B(e) {
    var t = { tryLoc: e[0] };
    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);
  }
  function P(e) {
    var t = e.completion || {};
    t.type = "normal", delete t.arg, e.completion = t;
  }
  function T(e) {
    this.tryEntries = [{ tryLoc: "root" }], e.forEach(B, this), this.reset(!0);
  }
  function F(e) {
    if (e || e === "") {
      var t = e[x];
      if (t) return t.call(e);
      if (typeof e.next == "function") return e;
      if (!isNaN(e.length)) {
        var r = -1, o = function n() {
          for (; ++r < e.length; ) if (p.call(e, r)) return n.value = e[r], n.done = !1, n;
          return n.value = f, n.done = !0, n;
        };
        return o.next = o;
      }
    }
    throw new TypeError(R(e) + " is not iterable");
  }
  return b.prototype = y, w(d, "constructor", { value: y, configurable: !0 }), w(y, "constructor", { value: b, configurable: !0 }), b.displayName = l(y, j, "GeneratorFunction"), h.isGeneratorFunction = function(e) {
    var t = typeof e == "function" && e.constructor;
    return !!t && (t === b || (t.displayName || t.name) === "GeneratorFunction");
  }, h.mark = function(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, l(e, j, "GeneratorFunction")), e.prototype = Object.create(d), e;
  }, h.awrap = function(e) {
    return { __await: e };
  }, Y(_.prototype), l(_.prototype, W, function() {
    return this;
  }), h.AsyncIterator = _, h.async = function(e, t, r, o, n) {
    n === void 0 && (n = Promise);
    var a = new _(A(e, t, r, o), n);
    return h.isGeneratorFunction(t) ? a : a.next().then(function(i) {
      return i.done ? i.value : a.next();
    });
  }, Y(d), l(d, j, "Generator"), l(d, x, function() {
    return this;
  }), l(d, "toString", function() {
    return "[object Generator]";
  }), h.keys = function(e) {
    var t = Object(e), r = [];
    for (var o in t) r.push(o);
    return r.reverse(), function n() {
      for (; r.length; ) {
        var a = r.pop();
        if (a in t) return n.value = a, n.done = !1, n;
      }
      return n.done = !0, n;
    };
  }, h.values = F, T.prototype = { constructor: T, reset: function(e) {
    if (this.prev = 0, this.next = 0, this.sent = this._sent = f, this.done = !1, this.delegate = null, this.method = "next", this.arg = f, this.tryEntries.forEach(P), !e) for (var t in this) t.charAt(0) === "t" && p.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = f);
  }, stop: function() {
    this.done = !0;
    var e = this.tryEntries[0].completion;
    if (e.type === "throw") throw e.arg;
    return this.rval;
  }, dispatchException: function(e) {
    if (this.done) throw e;
    var t = this;
    function r(u, g) {
      return a.type = "throw", a.arg = e, t.next = u, g && (t.method = "next", t.arg = f), !!g;
    }
    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
      var n = this.tryEntries[o], a = n.completion;
      if (n.tryLoc === "root") return r("end");
      if (n.tryLoc <= this.prev) {
        var i = p.call(n, "catchLoc"), c = p.call(n, "finallyLoc");
        if (i && c) {
          if (this.prev < n.catchLoc) return r(n.catchLoc, !0);
          if (this.prev < n.finallyLoc) return r(n.finallyLoc);
        } else if (i) {
          if (this.prev < n.catchLoc) return r(n.catchLoc, !0);
        } else {
          if (!c) throw Error("try statement without catch or finally");
          if (this.prev < n.finallyLoc) return r(n.finallyLoc);
        }
      }
    }
  }, abrupt: function(e, t) {
    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
      var o = this.tryEntries[r];
      if (o.tryLoc <= this.prev && p.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
        var n = o;
        break;
      }
    }
    n && (e === "break" || e === "continue") && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
    var a = n ? n.completion : {};
    return a.type = e, a.arg = t, n ? (this.method = "next", this.next = n.finallyLoc, s) : this.complete(a);
  }, complete: function(e, t) {
    if (e.type === "throw") throw e.arg;
    return e.type === "break" || e.type === "continue" ? this.next = e.arg : e.type === "return" ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : e.type === "normal" && t && (this.next = t), s;
  }, finish: function(e) {
    for (var t = this.tryEntries.length - 1; t >= 0; --t) {
      var r = this.tryEntries[t];
      if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), P(r), s;
    }
  }, catch: function(e) {
    for (var t = this.tryEntries.length - 1; t >= 0; --t) {
      var r = this.tryEntries[t];
      if (r.tryLoc === e) {
        var o = r.completion;
        if (o.type === "throw") {
          var n = o.arg;
          P(r);
        }
        return n;
      }
    }
    throw Error("illegal catch attempt");
  }, delegateYield: function(e, t, r) {
    return this.delegate = { iterator: F(e), resultName: t, nextLoc: r }, this.method === "next" && (this.arg = f), s;
  } }, h;
}
export {
  H as default
};
